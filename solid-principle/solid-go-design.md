# 和訳 [SOLID Go Design](https://dave.cheney.net/2016/08/20/solid-go-design) written by [David](https://dave.cheney.net/about)

## Code review: コードレビュー

仕事の一環としてコードレビューを行うのは誰ですか？さて、なぜあなたはコードレビューをするのですか？  
(誰かが「悪いコードを止めるために」と叫んだ)

悪いコードを見つけるためにコードレビューがある場合、レビューしているコードが良いか悪いかをどうやって知るのですか？

「この絵は美しい」や「この部屋は美しい」と言うのと同じように、「そのコードは醜い」や「ソースコードは美しい」と言っても問題ありませんが、これらは主観的な用語であり、私は良いコードまたは悪いコードの特性について話す客観的な方法について探しています。

## Bad code: 悪いコード

コードレビューで取り上げる可能性のある不良コードのプロパティにはどのようなものがありますか？

- Rigid: 厳しい、簡単に変更できない、融通がきかない、固定した
  - コードは厳格ですか？ 修正を困難にする、横柄なタイプとパラメーターの拘束具がありますか？
- Fragile: 壊れやすい
  - コードは壊れやすいですか？ わずかな変更がコードベースに波及し、計り知れない大混乱を引き起こしますか？
- Immobile: 動かない、動かせない
  - コードをリファクタリングするのは難しいですか？ import loop から 1 キーストローク離れていますか？
- Complex: 複雑な、複雑で理解しづらい
  - コードを持つためのコードはありますか、物事は過剰に設計されていますか？
- Verbose: 言葉数の多い、くどい、冗長な
  - コードを使用するのは疲れますか？ あなたがそれを見るとき、あなたはこのコードが何をしようとしているのか知ることができますか？

これらの前向きに聞こえる言葉ですか？ これらの単語がコードのレビューで使用されているのを見て喜んでいただけますか？  
おそらくそうではありません。

## Good design: 良い設計

しかし、これは改善であり、「変更が難しいため、これは好きではありません」、「コードが何をしようとしているのかわからないため、これは好きではありません」などと言うことができますが、 ポジティブな言葉でリードしていくというのはどうですか？

悪いデザインだけでなく、良いデザインの特性を説明し、客観的に表現できる方法があれば素晴らしいと思いませんか？

## SOLID: しっかりした、信頼できる、確かな

2002 年に、Robert Martin は彼の著書[「Agile Software Development, Principles, Patterns, and Practices」](https://www.amazon.com/Software-Development-Principles-Patterns-Practices/dp/0135974445)を出版しました。 その中で彼は、名前の最初の文字の後に、再利用可能なソフトウェア設計の 5 つの原則を説明しました。これを`SOLID principles`(`SOLIDの原則`)と呼びました。

- Single Responsibility Principle: 単一責任の原則
- Open / Closed Principle: オープン/クローズドの原則
- Liskov Substitution Principle: リスコフの置換原則
- Interface Segregation Principle: インターフェース分離の原則
- Dependency Inversion Principle: 依存性逆転の原則

この本は少し古くなっています、それが話している言語は 10 年以上前に使われているものです。 しかし、おそらく、SOLID の原則には、適切に設計された Go プログラムについて話す方法についての手がかりを与える可能性のあるいくつかの側面があります。

それで、これは私があなたと話し合うのに少し時間を費やしたいものです。

## 1.Single Responsibility Principle: 単一責任の原則

SOLID の最初の原則である`S`は、Single Responsibility Principle: 単一責任の原則です。

`A class should have one, and only one, reason to change. –Robert C Martin`
`クラスには、変更する理由が1つだけある必要があります。– Robert C Martin`

現在、Go には明らかにクラスがありません。代わりに、はるかに強力な構成の概念がありますが、クラスという単語の使用を振り返ることができれば、ここに何らかの価値があると思います。

なぜ、コードの一部に変更の理由を 1 つだけ含めることが重要なのですか？
さて、あなた自身のコードが変わるかもしれないという考えと同じくらい悲惨ですが、あなたのコードが依存しているコードがあなたの足元で変化していることを発見することははるかに苦痛です。 また、コードを変更する必要がある場合は、直接的な刺激に応じて変更する必要があります。巻き添え被害の犠牲になることはありません。

したがって、単一責任を持つコードには、変更する理由がほとんどありません。

### Coupling & Cohesion 結合と凝集度

ソフトウェアを変更するのがどれほど簡単か難しいかを説明する 2 つの言葉は、結合と凝集度です。

カップリング(結合)とは、2 つのものが一緒に変化することを表す言葉です。ある動きが別の動きを誘発します。

関連しているが別れている概念は、相互の引力である結束の概念です。

ソフトウェアのコンテキストでは、凝集性とは、コードの断片が互いに自然に引き付けられることを記述する特性です。

Go プログラムの結合度と凝集度を説明するために、SRP(Single Responsibility Principle) について説明するときに非常に一般的であるように、関数とメソッドについて説明する場合がありますが、それは Go のパッケージモデルから始まると思います。

### Package names パッケージ名

Go では、すべてのコードはパッケージ内にあり、適切に設計されたパッケージはその名前で始まります。 パッケージの名前は、その目的の説明であると同時に、name space(名前空間)のプレフィックスでもあります。 Go 標準ライブラリの優れたパッケージの例は次のとおりです。

- `net/http` http クライアントとサーバーを提供します
- `os/exec` 外部コマンドを実行する
- `encoding/json` JSON ドキュメントのエンコードとデコードを実装します。

自分のパッケージ内で別のパッケージのシンボルを使用する場合、これは、2 つのパッケージ間のソースレベルの結合を確立する `import`宣言によって実現されます。

### Bad package names: 悪いパッケージ名

この名前への焦点は、単なる学者ぶったものではありません。 名前が不十分なパッケージは、実際に目的があったとしても、その目的を列挙する機会を逃します。

パッケージ `server` は何を提供しますか？ サーバーであってほしい、しかしどのプロトコル？

パッケージ `private` は何を提供しますか？ 見てはいけないものは？ パブリックシンボルが必要ですか？

そして、パッケージ `common` は、愚かな行いの仲間であるパッケージ `utils` と同様に、これらの他の不快なものの近くで見つかることがよくあります。

このようなすべてのパッケージをキャッチすると、雑多なゴミ捨て場になります。また、多くの責任があるため、頻繁に、理由もなく変更されます。

### Go の UNIX 哲学

私の見解では、分離された設計についての議論は、Doug McIlroy の Unix 哲学に言及せずに完了することはできません。
小さくて鋭いツールを組み合わせて、より大きなタスクを解決します。多くの場合、元の作成者が想定していなかったタスクです。

Go パッケージは UNIX 哲学の精神を体現していると思います。 事実上、各 Go パッケージは、それ自体が小さな Go プログラムであり、単一の変更単位であり、単一の責任があります。

## 2.Open / Closed Principle: オープン/クローズドの原則

2 番目の原則である`O`は、1988 年に次のように書いた Bertrand Meyer によるオープン/クローズドの原則です。

`ソフトウェアエンティティは拡張のために開いている必要がありますが、変更のために閉じている必要があります。– Bertrand Meyer、オブジェクト指向ソフトウェア構築`

このアドバイスは、21 年後に書かれた言語にどのように適用されますか？

```
package main

type A struct {
    year int
}

func (a A) Greet() {
    fmt.Println("Hello GolangUK", a.year)
}

type B struct {
    A
}

func (b B) Greet() {
    fmt.Println("Welcome to GolangUK", b.year)
}

func main() {
    var a A
    a.year = 2016
    var b B
    b.year = 2016
    a.Greet() // Hello GolangUK 2016
    b.Greet() // Welcome to GolangUK 2016
}
```

タイプ`A`があり、フィールド`year`とメソッド`Greet`があります。 A を埋め込む 2 番目のタイプ`B`があります。したがって、A は B 内にフィールドとして埋め込まれ、B は A のメソッドを覆い隠す独自の Greet メソッドを提供できるため、呼び出し元は A にオーバーレイされた B のメソッドを確認できます。

ただし、埋め込みはメソッドだけでなく、埋め込み型のフィールドへのアクセスも提供します。 ご覧のとおり、A と B の両方が同じパッケージで定義されているため、B は、B 内で宣言されているかのように、A のプライベート年フィールドにアクセスできます。

したがって、埋め込みは、Go のタイプを拡張用に開くことができる強力なツールです。

```
package main

type Cat struct {
    Name string
}

func (c Cat) Legs() int {
    return 4
}

func (c Cat) PrintLegs() {
    fmt.Printf("I have %d legs\n", c.Legs())
}

type OctoCat struct {
    Cat
}

func (o OctoCat) Legs() int {
    return 5
}

func main() {
    var octo OctoCat
    fmt.Println(octo.Legs()) // 5
    octo.PrintLegs()         // I have 4 legs
}
```

この例では、`Cat`タイプがあり、`Legs`メソッドを使用して脚の数を数えることができます。
この `Cat`タイプを新しいタイプの`OctoCat`に埋め込み、`Octocat`には 5 本の脚があることを宣言します。ただし、`OctoCat`は独自の`Legs`メソッドを定義しており、`5`を返しますが、`PrintLegs`メソッドが呼び出されると、`4`を返します。

これは、`PrintLegs`が`Cat`タイプで定義されているためです。 レシーバーとして Cat を使用するため、Cat の`Legs`メソッドにディスパッチします。 `Cat`は、埋め込まれているタイプを認識していないため、埋め込みによってメソッドセットを変更することはできません。

したがって、Go のタイプは、`拡張`のために開かれていますが、`変更`のために閉じられていると言えます。

実際、Go のメソッドは、事前に宣言された仮パラメーター、つまりレシーバーを持つ関数の周りの`syntactic sugar(構文糖衣)`にすぎません。

```
func (c Cat) PrintLegs() {
    fmt.Printf("I have %d legs\n", c.Legs())
}

func PrintLegs(c Cat) {
    fmt.Printf("I have %d legs\n", c.Legs())
}
```

レシーバーは、関数の最初のパラメーターであるレシーバーに渡すものです。Go は関数のオーバーロードをサポートしていないため、OctoCats は通常の Cat の代わりにはなりません。 それは私を次の原則に導きます。

## 3.Liskov Substitution Principle: リスコフの置換原則

Barbara Liskov によって造られたリスコフの置換原則は、大まかに言って、発信者が違いを区別できないような振る舞いを示す場合、2 つのタイプが置換可能であると述べています。

クラスベース言語では、リスコフの置換原則は通常、さまざまな具体的なサブタイプを持つ抽象基本クラスの仕様として解釈されます。 ただし、Go にはクラスや継承がないため、抽象クラス階層の観点から置換を実装することはできません。

### Interfaces

代わりに、置換は Go のインターフェースの範囲です。 Go では、型は特定のインターフェイスを実装することを指定する必要はありません。代わりに、署名がインターフェイス宣言と一致するメソッドがある場合に限り、どの型もインターフェイスを実装します。

Go では、インターフェースは明示的にではなく暗黙的に満たされると言います。これは、言語内でのインターフェースの使用方法に大きな影響を及ぼします。

適切に設計されたインターフェースは、小さなインターフェースである可能性が高くなります。 一般的なイディオムは、インターフェイスに 1 つのメソッドしか含まれていないことです。 論理的には、他の方法では実行するのが難しいため、小さなインターフェイスは単純な実装につながります。 これは、共通の動作によって接続された単純な実装で構成されるパッケージにつながります。

### io.Reader

```
type Reader interface {
    // Read reads up to len(buf) bytes into buf.
    Read(buf []byte) (n int, err error)
}
```

これで`io.Reader`が表示されます。これは、私のお気に入りの Go インターフェイスです。

`io.Reader`インターフェイスは非常にシンプルです。 読み取りは、提供されたバッファーにデータを読み取り、読み取られたバイト数と読み取り中に発生したエラーを呼び出し元に返します。 シンプルに見えますが、非常に強力です。

`io.Reader`はバイトのストリームとして表現できるものなら何でも扱うので、ほぼ何でもリーダーを構築できます。
定数文字列、バイト配列、標準入力、ネットワークストリーム、`gzip`で圧縮された`tar`ファイル、`ssh`を介してリモートで実行されるコマンドの標準出力など。

そして、これらの実装はすべて、同じ単純な契約を履行するため、相互に置き換えることができます。

したがって、Go に適用されたリスコフの置換原則は、故 Jim Weirich からのこの素敵な格言によって要約することができます。
`これ以上は必要ありません、それ以下を約束します。– Jim Weirich`

そして、これは 4 番目の SOLID 原則へ円滑に移行します。

## 4.Interface Segregation Principle: インターフェース分離の原則

4 番目の原則は、インターフェイス分離の原則です。

`クライアントは、使用しないメソッドに依存することを強制されるべきではありません。– Robert C. Martin`

Go では、インターフェイス分離の原則の適用は、関数がその仕事をするために必要な動作を分離するプロセスを参照できます。 具体的な例として、ドキュメント構造をディスクに永続化する関数を作成するタスクが与えられたとします。

```
// Save writes the contents of doc to the file f.
func Save(f *os.File, doc *Document) error
```

この関数を定義して、`Save`と呼びましょう。この関数は、提供されたドキュメントを書き込むための宛先として`*os.File`を取ります。 しかし、これにはいくつかの問題があります。

保存の署名により、データをネットワーク上の場所に書き込むオプションが排除されます。ネットワークストレージが後で必要になる可能性が高いと仮定すると、この関数のシグネチャを変更する必要があり、すべての呼び出し元に影響を与えます。

`Save`はディスク上のファイルを直接操作するため、テストするのは不快です。 その動作を検証するために、テストは書き込まれた後にファイルの内容を読み取る必要があります。 さらに、テストでは、`f`が一時的な場所に書き込まれ、その後は常に削除されることを確認する必要があります。

`*os.File`は、ディレクトリの読み取りやパスがシンボリックリンクであるかどうかの確認など、保存に関係のない多くのメソッドも定義します。 Save 関数の署名で、関連する`*os.File`の部分のみを記述できると便利です。

これらの問題について何ができるでしょうか。

```
// Save writes the contents of doc to the supplied ReadWriterCloser.
func Save(rwc io.ReadWriteCloser, doc *Document) error
```

`io.ReadWriteCloser`を使用すると、インターフェイス分離の原則を適用して Save を再定義し、より一般的なファイル形式のものを記述するインターフェイスを取得できます。

この変更により、`io.ReadWriteCloser`インターフェイスを実装するすべてのタイプを以前の`*os.File`の代わりに使用できるようになりました。 これにより、Save はそのアプリケーションでより広くなり、Save の呼び出し元に`*os.File`タイプのどのメソッドがその操作に関連するかが明確になります。

Save の作成者として、`io.ReadWriteCloser`インターフェイスの背後に隠されているため、`*os.File`でこれらの無関係なメソッドを呼び出すオプションがなくなりました。 ただし、インターフェイス分離の原則をもう少し進めることができます。

まず、Save が単一責任の原則に従っている場合、書き込んだばかりのファイルを読み取ってその内容を確認する可能性はほとんどありません。これは、別のコードの責任である必要があります。 したがって、Save に渡すインターフェイスの仕様を、書き込みと終了だけに絞り込むことができます。

```
// Save writes the contents of doc to the supplied WriteCloser.
func Save(wc io.WriteCloser, doc *Document) error
```

次に、ファイル形式のように見せたいという願いから受け継いだストリームを閉じるメカニズムを Save に提供することで、どのような状況で`wc`を閉じるのかという疑問が生じます。 おそらく Save は無条件に Close を呼び出すか、成功した場合は Close が呼び出される可能性があります。

これは、ドキュメントの書き込み後にストリームに追加のデータを書き込みたい場合があるため、Save の呼び出し元に問題を提示します。

```
type NopCloser struct {
        io.Writer
}

// Close has no effect on the underlying writer.
func (c *NopCloser) Close() error { return nil }
```

大まかな解決策は、io.Writer を埋め込み、Close メソッドをオーバーライドして、Save が基になるストリームを閉じないようにする新しいタイプを定義することです。

しかし、NopCloser は実際には何も閉じないため、これはおそらくリスコフの置換原則の違反になります。

```
// Save writes the contents of doc to the supplied Writer.
func Save(w io.Writer, doc *Document) error
```

より良い解決策は、保存を再定義して io.Writer のみを取得し、ストリームにデータを書き込む以外のことを行う責任を完全に取り除くことです。

インターフェース分離の原則を Save 関数に適用することにより、結果は同時に、要件に関して最も具体的な関数になりました。書き込み可能なものだけが必要であり、その関数で最も一般的なものが使用できるようになりました。 保存して、io.Writer を実装するものにデータを保存します。

`Goの大まかな目安は、インターフェイスを受け入れ、構造体を返すことです。– Jack Lindamood`

数歩後退して、この引用は、過去数年にわたって Go の時代精神に浸透している興味深い meme: ミーム(文化的遺伝子) です。

このツイートにはニュアンスがなく、これは Jack のせいではありませんが、防御可能な Go デザインの最初の伝承の 1 つを表していると思います。

## 5.Dependency Inversion Principle

最後の SOLID の原則は、依存性逆転の原則であり、次のように述べています。

`高レベルのモジュールは、低レベルのモジュールに依存しないでください。 どちらも抽象化に依存する必要があります。 抽象化は詳細に依存するべきではありません。 詳細は抽象化に依存する必要があります。 – Robert C. Martin`

しかし、実際には、依存性逆転は Go プログラマーにとって何を意味するのでしょうか。

これまでに説明したすべての原則を適用した場合、コードはすでに個別のパッケージに組み込まれているはずです。各パッケージには、明確に定義された単一の責任または目的があります。 コードは、インターフェースの観点からその依存関係を記述する必要があり、それらのインターフェースは、それらの関数が必要とする動作のみを記述するように因数分解する必要があります。 言い換えれば、やるべきことはあまり残ってはいけません。

つまり、Martin がここで話しているのは、確かに Go のコンテキストであり、import グラフの構造です。

Go では、import グラフは非循環である必要があります。 この非周期的な要件を尊重しないことは、コンパイルの失敗の理由ですが、より深刻なことに、設計における重大なエラーを表しています。

適切に設計された Go プログラムの import グラフに等しいものはすべて、高くて狭いのではなく、広くて比較的平らである必要があります。 別のパッケージの助けを借りずに機能を操作できないパッケージがある場合、それはおそらく、コードがパッケージの境界に沿って十分に因数分解されていないことを示しています。

依存性逆転の原則は、詳細の責任を import グラフのできるだけ高い位置にある main パッケージまたはトップレベルのハンドラーにプッシュし、下位レベルのコードは抽象化インターフェイスを処理するようにすることをお勧めします。

## SOLID Go Design

要約すると、Go に適用すると、SOLID の各原則は設計に関する強力なステートメントですが、まとめると、中心的なテーマがあります。

- 単一責任の原則

  - 関数、タイプ、およびメソッドを、自然なまとまりを示すパッケージに構造化することを推奨します。タイプは一緒に属し、関数は単一の目的を果たします。

- オープン/クローズド原則

  - 埋め込みを使用して単純なタイプをより複雑なタイプに構成することを推奨します。

- リスコフの置換原則

  - 具体的なタイプではなく、インターフェースの観点からパッケージ間の依存関係を表現することを推奨しています。小さなインターフェースを定義することで、実装がその契約を忠実に満たすことができると確信できます。

- インターフェイス置換原則

  - その考えをさらに発展させ、必要な動作のみに依存する関数とメソッドを定義することを推奨します。関数が単一のメソッドを持つインターフェースタイプのパラメーターのみを必要とする場合、この関数が 1 つの責任しか持たない可能性が高くなります。

- 依存性逆転の原則
  - パッケージが依存するものの知識をコンパイル時から実行時に移動することを推奨します。これは、特定のパッケージで使用されるインポートステートメントの数が減ったことでわかります。

この話を要約すると、おそらくそうなるでしょう。インターフェースを使用すると、SOLID の原則を Go プログラムに適用できます。

インターフェースにより、Go プログラマーは、パッケージがどのように提供するかではなく、何を提供するかを説明できるからです。これはすべて、「decoupling:分離」の別の言い方です。疎結合のソフトウェアは変更が容易なソフトウェアであるため、これは確かに目標です。

Sandi Metz が指摘するように:
`デザインは、今日機能し、永遠に簡単に変更できるようにする必要のあるコードを配置する技術です。– Sandi Metz`

Go が企業が長期的に投資する言語になる場合は、Go プログラムの保守、変更のしやすさが決定の重要な要素になるためです。

## Coda: 終結部

最後に、私がこの話を始めた質問に戻りましょう。 世界には何人の Go プログラマーがいますか？ これは私の推測です:
`By 2020, there will be 500,000 Go developers.-me`

50 万人の Go プログラマーが自分の時間で何をしますか？ もちろん、彼らは多くの Go コードを作成します。正直なところ、すべてが良いわけではなく、かなり悪いものもあります。

私はこれを残酷だとは言いませんが、他の言語、つまりあなたが生まれた言語から Go への開発の経験を持つこの部屋にいる皆さんは、自分の経験から真実の要素があることを知っています。 この予測に。
`C ++内には、抜け出すのに苦労しているはるかに小さくてクリーンな言語があります。–Bjarne Stroustrup、C ++の設計と進化`

すべての囲碁プログラマーが私たちの言語を成功させる機会は、人々が今日の C ++について冗談を言っているように囲碁について話し始めるような混乱を引き起こさないという私たちの集合的な能力に直接かかっています。

他の言語が肥大化し、冗長で、複雑すぎることを嘲笑する物語は、いつの日か Go に向けられる可能性があります。これが起こるのを見たくないので、リクエストがあります。

Go プログラマーは、フレームワークについてはあまり話さず、デザインについてもっと話を始める必要があります。 パフォーマンスに焦点を合わせるのをやめ、代わりに再利用に焦点を合わせる必要があります。

私が見たいのは、今日の言語の選択や制限に関係なく、ソリューションを設計し、実際の問題を解決する方法について話している人々です。

私が聞きたいのは、うまく設計され、分離され、再利用可能で、とりわけ変化に対応する方法で Go プログラムを設計する方法について話している人々です。

## … one more thing

したがって、優れたソフトウェアをどのように作成するかを世界中に伝える必要があります。 優れたソフトウェア、構成可能なソフトウェア、変更しやすいソフトウェア、および Go を使用した変更方法を示します。 そして、これはあなたから始まります。

デザインについて話し始めてほしいです。ここで紹介したアイデアのいくつかを使用してください。自分で調査して、それらのアイデアをプロジェクトに適用してください。 それから私はあなたにしたい：

- それについてのブログ投稿を書いてください。
- あなたがしたことについてワークショップに教えてください。
- あなたが学んだことについて本を書いてください。
- そして、来年この会議に戻って、あなたが達成したことについて話してください。

これらのことを行うことで、長持ちするように設計されたプログラムを気にする Go 開発者の文化を構築できるからです。

ありがとうございました。
