# Authentication

## Authentication: 認証 とAuthorization/Permission:認可の違い
- 認証: ユーザーの本人確認、通信の相手が誰（何）であるかを確認すること
- 認可: とある特定の条件に対して、リソースアクセスの権限を与えること

認証に基づく認可というケースが多くのシステムで発生する

## OAuth2.0とは
- OAuth2.0は認可を行うためのプロトコル
- 所有者の代わりにリソースへのアクセスを許可するためのプロトコル
- サードパーティーアプリケーションによるHTTPサービスへの限定的なアクセスを可能にする認可フレームワーク
- エンドユーザーがあるサービスに対して別のサービスへのアクセスを許可するためのトークンを発行するための手段
  - これによって、SNSのアカウントでログインすることで、認可によって、連携しているサービスへのアクセスが可能になる
- OAuthは認可のためのプロトコルだが、認証を行うためのプロトコルではない
- [単なる OAuth 2.0 を認証に使うと、車が通れるほどのどでかいセキュリティー・ホールができる
](https://www.sakimura.org/2012/02/1487/)
  - 悪意のあるサイトは`access_token`を取得後、任意のOAuth認証に対応しているサイトへのアクセスができてしまう
  - [図解](https://tech-lab.sios.jp/archives/13002)

### OAuth2.0の流れ
前提条件として、`認可サーバー`はここでは、Googleとする
1. Webサイトにアクセス
2. 「Googleアカウントでログイン」をクリック
3. これにより、認可サーバー(Google)にリダイレクトされる
4. ユーザーに、Googleのリソース(情報)へのアクセスの認可を許可するかどうか確認する(もしくは連携許可)
5. 認可サーバーからアクセストークンが発行される
6. アクセストークンを使って、Googleのリソースにアクセスできる

## OpenID Connect (OIDC)
- OAuth2.0 の拡張規格で、`認証`を行うこともできる
- つまり、認証を目的とするならば、`OAuth2.0`ではなく、`OpenID Connect`を使うべき
- サードパーティーのサービス、例えばGoogleやFacebookなどの認証サーバーを使ってユーザー認証を行うためのプロトコル
- OpenID Connectを利用したログインサービスは`ソーシャルログイン`と呼ばれる

### OpenID Connectの流れ
1. ユーザーはアプリにアクセスし、ログインをクリック
2. そのアプリは認証クライアントとして認証サーバー側に認証を要求する
3. 認証サーバーはユーザー認証を行い、必要な`IDトークン` (アクセスするための認証情報) を発行してクライアントに返す

- 認証クライアントとなるアプリを `Relying Party`
- 認証サービスを行う事業者を `OpenID Provider` という
- IDトークンを用いて、`Relying Party`は外部API（Google APIsやFacebook Graph APIなど）を利用することができる

### OpenID ConnectのIDトークンについて
- Webの世界的な標準規格である`RFC 7519` (JSON Web Token) で定められている
- このIDトークンには署名が付与されている
- 署名は暗号化され、さらにトークンの中にはユーザー情報の他にもトークンの発行者、トークン有効期間などの情報を含めることができる


## SAML認証
一つのアカウント情報を持って複数のサービスで使い回せる`シングルサインオン（SSO）`などに利用される

## WebAuthn



## Keycloak