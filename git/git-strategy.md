# Git Repository Strategy

## Multirepo

- マルチリポジトリ戦略では、各プロジェクトまたはコンポーネントが個別のリポジトリに保存される
- このアプローチは、プロジェクト構造が単純な小規模から中規模の組織でよく使用される

### 長所：

- プロジェクトとコンポーネントの明確な分離。
- コードベースが小さいほど、管理とナビゲートが容易になる
- マージの競合のリスクが低くなる
- セキュリティとアクセス制御をより簡単に適用できる

### 短所：

- チーム間のコード共有とコラボレーションは、より困難になる可能性がある
- プロジェクト間の依存関係は、すぐには明確にならない場合がある
- ビルドと展開のプロセスは、より複雑になる可能性がある
- コードのリファクタリングとレビューは、より時間がかかる可能性がある

## Monorepo

- Monorepo 戦略では、プロジェクトのすべてのソース コードが 1 つのリポジトリに格納される
- このアプローチは、複数のチームが相互に依存するプロジェクトに取り組んでいる大規模な組織でよく使用される

### 長所：

- チームやプロジェクト間のコード共有とコラボレーションが容易になる
- 簡素化されたビルドおよびデプロイ プロセス
- 依存関係の管理と一貫性の確保が容易になる
- 単一のコードベースにより、コードのリファクタリングとコード レビューが容易になる

### 短所：

- コードベースが大きいと、特定のコードをナビゲートして見つけるのが難しくなる可能性がある
- コードの変更は、プロジェクトの他の部分に予期しない結果をもたらす可能性がある
- マージ競合のリスクの増加

## Monorepo (その２)

- リポジトリには、複数の論理プロジェクト（iOS クライアントと Web アプリケーションなど）が含まれる
- これらのプロジェクトは、ほとんどの場合、無関係であるか、接続が緩んでいるか、他の手段（依存関係管理ツールなど）で接続できる
- リポジトリは多くの点で大きい
  - コミット数
  - ブランチおよび/またはタグの数
  - 追跡されるコンテンツのサイズ（リポジトリの.git ディレクトリを調べて測定）

### 利点

- コードの再利用の容易さ
  - 依存関係パッケージマネージャーを必要とせずに、同様の機能または通信プロトコルを共有ライブラリに抽象化し、プロジェクトに直接含めることができる。
- 簡素化された依存関係管理
  - 複数のプロジェクトがサードパーティの依存関係に依存している複数のリポジトリ環境では、その依存関係が複数回ダウンロードまたは構築される可能性がある。モノリポでは、参照される依存関係がすべて同じコードベースに存在するため、ビルドを簡単に最適化できる。
- アトミックコミット [不可分操作](https://ja.wikipedia.org/wiki/%E4%B8%8D%E5%8F%AF%E5%88%86%E6%93%8D%E4%BD%9C)
  - 一緒に機能するプロジェクトが別々のリポジトリに含まれている場合、リリースは、あるプロジェクトのどのバージョンが他のプロジェクトと機能するかを同期する必要がある。そして、十分に大きなプロジェクトでは、依存関係間の互換性のあるバージョンを管理することは、依存関係地獄になる可能性がある。モノレポでは、開発者が複数のプロジェクトをアトミックに変更する可能性があるため、この問題は解消できる。
- 大規模なコードリファクタリング
  - 開発者はプロジェクト全体にアクセスできるため、リファクタリングにより、プロジェクトのすべての部分がリファクタリング後も機能し続けることが保証される。
- チーム間のコラボレーション
  - ソースの依存関係（ソースからコンパイルされた依存関係）を使用するモノリポでは、チームは他のチームが取り組んでいるプロジェクトを改善できる。これにより、柔軟なコード所有権が得られる。

### 制限と欠点

- バージョン情報の喪失
  - 必須ではないが、一部のモノリポ ビルドでは、リポジトリ内のすべてのプロジェクトで 1 つのバージョン番号が使用される。これにより、プロジェクトごとのセマンティックバージョニングが失われる。
- プロジェクトごとのアクセス制御の欠如
  分割リポジトリを使用すると、必要に応じてリポジトリへのアクセスを許可できる。monorepo を使用すると、プロジェクト内のすべてのソフトウェアへの読み取りアクセスが可能になり、新しいセキュリティの問題が発生する可能性がある。これを回避するために、例えば Subversion を使用すると、リポジトリの任意の部分（単一のディレクトリでも）をダウンロードでき、パスベースの承認を使用してリポジトリの特定の部分へのアクセスを制限できる。
- デフォルトでより多くのストレージが必要
  分割リポジトリでは、デフォルトで関心のあるプロジェクトのみをフェッチするが、モノリポでは、デフォルトですべてのプロジェクトをチェックアウトする。これは、かなりの量のストレージスペースを占有する可能性がある。すべてのバージョン管理システムには部分的なチェックアウトを実行するメカニズムがあるが、これを行うと、モノリポの利点のいくつかが無効になる。
- Git は、コミットが行われるたびにツリー全体の状態を追跡する。これは、単一または関連するプロジェクトには問題ないが、多くの無関係なプロジェクトを含むリポジトリでは扱いにくくなる。簡単に言えば、ツリーの無関係な部分でのコミットは、開発者に関連するサブツリーに影響を与える。この問題は、ツリーの履歴を進める多数のコミットで大規模に顕著になる。ブランチチップは常に変化しているため、変更をプッシュするには、ローカルで頻繁にマージまたはリベースする必要がある。
- Git では、タグは特定のコミットの名前付きエイリアスであり、ツリー全体を参照する。ただし、モノリポのコンテキストでは、タグの有用性は低下する。モノリポに継続的にデプロイされている Web アプリケーションで作業している場合、バージョン管理された iOS クライアントのリリースタグに何の関連性もない（無駄）

### パフォーマンスの問題

- コミット数
  - 時間の経過とともに、これはかなりの成長率で多数のコミットにつながる可能性がある
  - コミット数が多いと、履歴が深くなるにつれてグラフ系コマンドが遅くなる可能性がある
- 参照数 (ブランチやタグ)
  - 多数の参照（つまり、ブランチまたはタグ）は、さまざまな方法でパフォーマンスに影響を与える
- 追跡されたファイルの数
  - インデックスまたはディレクトリキャッシュ（.git/index）は、リポジトリ内のすべてのファイルを追跡する
  - 追跡されるファイルの数は、多くの操作のパフォーマンスに影響を与える
- 大きなファイル
- 複合効果
  - ファイルの数、変更の頻度、サイズのいずれであっても、これらの問題を組み合わせると、パフォーマンスへの影響が大きくなる

### パフォーマンス問題の緩和

- 参照を削除 (ブランチやタグの削除)
- 多数のファイルの処理
  - バッファキャッシュとして使用できる十分なメモリを備えた高速ローカルストレージを使用する
- コミット数は抑える
  - 機能ブランチは 1 機能 1 コミットでいい粒度で、機能を分割する
- リポジトリメンテナンスの改善
  - 問題
    - デフォルトでは、GitHub は 50 回の git push 操作ごと、または 40MB の解凍されたファイルを受け取った後にリポジトリメンテナンスルーチンを実行する。メンテナンスには数秒から数分かかる。
    - 開発者が多い大規模なモノリポジトリの場合、50 回のプッシュ操作の蓄積に時間がかからないため、開発者がリポジトリに変更をプッシュしている間、メンテナンスが頻繁にスケジュールされる
    - リポジトリがメンテナンスに失敗すると、プッシュ更新と参照更新の両方のパフォーマンスが低下する
  - 以下コマンドの実行にて不要なファイルをへらす
  ```
  % git gc # Cleanup unnecessary files and optimize the local repository
  % git repack -Ad # Pack unpacked objects in a repository
  % git prune # Prune all unreachable objects from the object database
  ```

### ビルドソフトウェアのスケーリング

モノリポでうまく機能するビルドツールはほとんどなく、チェックイン時にリポジトリ全体のビルドと継続的インテグレーションテストが実行されるフローはパフォーマンスの問題を引き起こす。

- [Buck](https://buck.build/) is Facebook's monorepo-oriented build system.
- [Bazel](https://github.com/bazelbuild/bazel) is Google's monorepo-oriented build system.
- [bit](https://github.com/teambit/bit) is a tool for building and managing JavaScript projects with multiple components, and managing the dependency graph of components.

### 所管

フロントエンドとバックエンドは分けたほうがいい。
この場合の問題点としてフロントエンドとバックエンドの I/F が変更された場合の整合性であり、これは`Schema Driven Development`を取り入れることで解決できないだろうか？

### References

- [wiki Monorepo](https://en.wikipedia.org/wiki/Monorepo)
- [Monorepos in Git](https://www.atlassian.com/git/tutorials/monorepos)
- [Improving large monorepo performance on GitHub](https://github.blog/2021-03-16-improving-large-monorepo-performance-on-github/)
- [awesome-monorepo](https://github.com/korfuri/awesome-monorepo)
- [Monolith→MultiRepo→MonoRepo へと移行した理由](https://logmi.jp/tech/articles/321292)
- [メルカリ Shops での monorepo 開発体験記](https://engineering.mercari.com/blog/entry/20210817-8f561697cc/)
- [メルカリ Shops の技術スタックと、その選定理由](https://engineering.mercari.com/blog/entry/20210810-mercari-shops-tech-stack/)
