# UUID

- 順序付けられた UUID バリアントを使わないと、パフォーマンスが悪い
  - ランダムな UUID は、B-Tree インデックスには適していない
  - B-tree インデックスは、自動インクリメントされたカラムや時間順にソートされたカラムなど、順序付けられた値で最もよく機能する
- バージョン`6`や`7`のような時間ベースの UUID は、値を可能な限りシーケンシャルに近づけながら一意性を保証することができる

## Version

### UUID v1

- 時間ベースの UUID
- MySQL では Default で使われている

### UUID v2

- 衝突の可能性があり、使われていない

### UUID v3

- MD5 ハッシュアルゴリズムを使って生成する

### UUID v4 (2024時点でも一般的に利用されているが、v7やULIDへの過渡期にあたる)

- ランダムバリアント
- PostgreSQL では Default で使われている

### UUID v5

- SHA1 ハッシュアルゴリズムを使って生成する

### UUID v6（Time Ordered UUID）

UUIDバージョン1ではタイムスタンプが特定の形式で保存されるため、生成されたUUIDの配列で時間の順序が必ずしも保持されないという問題があったが、バージョン6ではこれを改善し、時間の順序が維持されるように設計されている

- **生成方法**: タイムスタンプを先頭に配置し、それに引き続きランダムまたは固定の要素（例えばMACアドレス）が含まれる。
- **ユニーク性**: 非常に高い。時間ベースの要素により順序が保証され、重複のリスクを低減。
- **用途**: 生成されたUUIDが時間順に並ぶ必要がある場合、例えば時系列データの管理など。

### UUID v7（Unix時代ベースUUID）

UUIDバージョン7はUNIXエポック（1970年1月1日からの経過秒数）に基づいて、タイムオーダードなUUIDを生成するもの。これにより、生成するシステムの負荷を軽減することが可能。

- **生成方法**: UNIXエポックタイムスタンプに基づいて、残りの部分はランダムまたは擬似ランダムな数値で埋められる。
- **ユニーク性**: 非常に高い。一貫性のある時間順序が保証され、重複のリスクが低減。
- **用途**: 時間順を保証する必要があるアプリケーション、例えばログファイルやトランザクション記録など。

## DB のユニークキー

プライマリキーを UUID にすると新しいデータがインデックス内にランダムに分散されるため、大規模なデータセットから最新のデータを取得したい場合に多数のデータベースインデックスページを走査しなくてはならず、キャッシュヒット率が低下してしまう

- [UUID なのにデータベースのプライマリキーに設定してもパフォーマンスの問題を起こさない「UUIDv7」の標準化作業が進行中](https://gigazine.net/news/20231023-uuid-v7/)
- [Goodbye integers. Hello UUIDv7!](https://buildkite.com/blog/goodbye-integers-hello-uuids)

- [PostgreSQL のプライマリーキーは SERIAL と UUID のどっちが速いのか実験してみた](https://qiita.com/jnchito/items/3ea13928d6aeb732bae2)
  - INSERT においては差はないが、SELECT で顕著なパフォーマンスの差が出る

### [データベースでユニークキーに UUID を使うメリットは何ですか？](https://jp.quora.com/%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9%E3%81%A7%E3%83%A6%E3%83%8B%E3%83%BC%E3%82%AF%E3%82%AD%E3%83%BC%E3%81%ABUUID%E3%82%92%E4%BD%BF%E3%81%86%E3%83%A1%E3%83%AA%E3%83%83%E3%83%88%E3%81%AF%E4%BD%95)

- `プライマリキーには原則としてデータベース側で発行される自動インクリメントの連番を使っておくのが間違いない`
- UUID を使いたくなる理由
  - 大規模な分散システムを設計していて SPOF が許されない
  - ID を乱数化してユーザーから類推しにくくする
- プライマリキーを UUID にする莫大なコストには全く見合わない
  - プライマリキーは連番のままにしておき、`public_id`という別カラムを用意してそこに乱数ベースのデータを入れてユニーク制約をかけておく
- ユーザーに見える UI に出てくる ID は常に乱数ベースの public_id を使い、内部での処理にはすべて連番の ID を使う
