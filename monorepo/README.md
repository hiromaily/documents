# Monorepo (NPM package)

モノレポ（monorepo）とは、「モノリシック・リポジトリ」の略で、多くのパッケージやモジュールを単一のリポジトリに格納するバージョン管理戦略のことだが、NPM パッケージのおいては、ひとつの Git リポジトリで複数の NPM パッケージを扱う形態。シングルレポの開発ツールの統一的管理の良さと、マルチレポの再利用可能なモジュールを切り出してリリースする点の両方を兼ね備える。

## Monorepo の問題

モノレポには多くの利点がありますが、スケールするのに苦労する。 それぞれのワークスペースは、独自のテスト・スイート、独自のリンティング、独自のビルド・プロセスを持つため、単一のモノレポには、何千もの実行タスクがあるかもしれない。

## ルートパッケージ(root package)

モノレポにおけるトップレベルの NPM パッケージ。通常は、リポジトリのトップレベル。このパッケージはワークスペースを管理するパッケージ。NPM では配布しない。ルートパッケージには、開発ツールの統一的設定や、CI 設定が置かれ、テストフレームワークなどの開発ツールがインストールされる。

## ワークスペース (workspaces)

モノレポにおける NPM で配布するパッケージ。通常、`/packages` ディレクトリにワークスペースごとのディレクトリを作る。
単に`パッケージ`と言った場合は、ワークスペースを指すことがある。モノレポには複数のワークスペースが存在しうる。

## hoisting (吊り上げ) 

※ ChatGPTより

`pnpm` などのパッケージ マネージャーのコンテキストでの`hoisting`とは、依存関係をディレクトリ構造内の上位レベル (通常はプロジェクトまたはワークスペースのルート) に移動するプロセスを指し、複数のパッケージまたはワークスペース間で共有できるようにする。これにより、プロジェクトのさまざまな部分で依存関係が重複するのを防ぎ、依存関係の管理を簡素化できる。

### hoisting の詳細

#### 1. **hoistingの基本概念**

- 複数のパッケージまたはワークスペースを含むmonorepoでは、各パッケージの `package.json` ファイルで定義された独自の依存関係セットが存在する場合がある。
- 一部の依存関係は、複数のパッケージ間で共通している場合がある。たとえば、複数のパッケージが `eslint` に依存している場合がある。
- 各パッケージの `node_modules` ディレクトリに `eslint` を個別にインストールする代わりに、パッケージ マネージャーはこの依存関係を上位レベル (通常はルート `node_modules`) に`hoisting`して、それを必要とするすべてのパッケージからアクセスできるようにする。

#### 2. **pnpm が hoisting を処理する方法**

- **フラットなノード モジュール構造 (設計による):** npm や Yarn とは異なり、pnpm はデフォルトでフラットな `node_modules` 構造を作成しない。代わりに、シンボリック リンクを使用して、各パッケージが必要な依存関係の正確なバージョンのみを取得する深い構造を作成する。
- **効率性のためのhoisting:** この深い構造であっても、pnpm は共通の依存関係をルート `node_modules` に hoisting することで依存関係ツリーを最適化する。これにより、これらの依存関係をモノレポ内のすべてのパッケージで共有できるようになり、重複が減り、インストール速度が向上する。
- **依存関係の解決:** パッケージに依存関係が必要な場合、pnpm は最初にパッケージ自体の `node_modules` を検索する。そこで依存関係が見つからない場合は、ディレクトリ構造を上に移動し、ルート `node_modules` または依存関係が`hoisting`されている可能性のある場所を確認する。

#### 3. **モノレポでの hoisting の例**

- **モノレポの構造:**

```
/monorepo
├── package.json (ルートレベルの package.json)
├── node_modules/ ( hoisting された依存関係はここに配置)
├── packages/
│ ├── package-a/
│ │ ├── package.json
│ │ └── node_modules/
│ ├── package-b/
│ │ ├── package.json
│ │ └── node_modules/
│ └── package-c/
│ ├── package.json
│ └── node_modules/
└── pnpm-workspace.yaml
```
- **シナリオ:**
- `package-a`, `package-b` と `package-c` はすべて、`eslint` を依存関係としてリストする。
- pnpm は `eslint` を `/monorepo/node_modules/` の下のルート レベルに 1 回インストールし、すべてのパッケージはこの hoisting されたバージョンを使用する。

#### 4. **hoistingの利点**

- **ディスク スペースの効率:** 共通の依存関係をhoistingすると、同じ依存関係の複数のコピーがすべてのパッケージにインストールされないため、ディスク スペースの使用量が削減される。
- **インストールの高速化:**  hoisting により、共通の依存関係が 1 回だけインストールされるため、依存関係のインストールに必要な全体的な時間が短縮される。
- **依存関係の管理が簡単:**  hoisting により、バージョンの競合や重複を回避できるため、大規模なコードベース全体で依存関係を管理しやすくなる。

#### 5. ** hoisting に関する潜在的な問題**

- **バージョンの競合:** 異なるパッケージで同じ依存関係の異なるバージョンが必要な場合、 hoisting が不可能になるか、パッケージ マネージャーが特定の方法で競合を解決する必要がある可能性がある。
- **依存関係の可視性:**  hoisting は、特に直接のパッケージの `package.json` にリストされていない場合、開発者が依存関係がどこから解決されているかを認識しない可能性があるため、混乱を招くことがある。**[最大のデメリット]**

#### 6. **hoisting の制御**

- **`pnpm` を使用すると、 hoisting をある程度制御できる:**
- **`shamefully-hoist`:** このオプションは、npm や Yarn などの他のパッケージ マネージャーの動作を模倣して、pnpm にすべての依存関係を hoisting するように強制する。
- **`public-hoist-patterns`:** これにより、 hoisting する必要があるパッケージの特定のパターンを定義できる。

### 結論

`pnpm` の hoisting は、冗長性を減らしてパフォーマンスを向上させることでモノレポの依存関係管理を最適化する強力な機能だが、バージョンの競合や依存関係の可視性に関連する潜在的な問題を回避するには、プロジェクト全体で依存関係がどのように解決されるかを理解する必要がある。


## References

- [npm workspaces とモノレポ探検記](https://zenn.dev/suin/scraps/20896e54419069)
- [Turborepo を使ってモノレポ構成の npm パッケージ を管理する](https://cam-inc.co.jp/p/techblog/728530570199434396)
- [モノレポによるマイクロサービスの開発運用](https://note.com/tinkermodejapan/n/nb14009fe837f)
- [【大きいプロジェクトやモノレポ向き？】pnpm の特徴と npm、yarn との比較](https://www.geeklibrary.jp/counter-attack/pnpm/)
  - [Benchmarks of JavaScript Package Managers](https://pnpm.io/benchmarks)
