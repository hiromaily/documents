# Light Client

- [IBC Light Client](https://ibcprotocol.org/lightClients/)
- [Blockchain Light Client](https://medium.com/codechain/blockchain-light-client-1171dfa1269a)
- [Tendermint Light Client](https://medium.com/tendermint/everything-you-need-to-know-about-the-tendermint-light-client-f80d03856f98)
- [ブロックチェーン上で他のブロックチェーンを検証する方法](https://medium.com/@FullyProtocol/%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E3%83%81%E3%82%A7%E3%83%BC%E3%83%B3%E4%B8%8A%E3%81%A7%E4%BB%96%E3%81%AE%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E3%83%81%E3%82%A7%E3%83%BC%E3%83%B3%E3%82%92%E6%A4%9C%E8%A8%BC%E3%81%99%E3%82%8B%E6%96%B9%E6%B3%95-e62558ec4e73)
- [Exnnum Light Client](https://exonum.com/doc/version/latest/architecture/clients/)

## 概要

- Light Client はトランザクションの状態を検証するが、そのためにブロックチェーンの一部の情報のみを保存する
- ブロックチェーンの構造は、Header, Transaction, State, Cache となっている
- Header
  - Chain を形成する最小単位の構造で、以下が含まれる
    - 前のブロックの Hash
    - タイムスタンプ
  - Light Client の目的はヘッダーを検証すること
  - ヘッダーを検証するだけで Merkle ツリー内のすべての情報が検証される
- Header+Transaction
  - これが「ブロック」になる
  - ブロックを提案/マイニングするノードはブロックを公開し、他のノードはそれらのブロックを検証する
- Header+Transaction+State

  - ヘッダーによって検証できる最大の範囲
  - すべてのノードがまったく同じ値を持つことがプロトコルで保証されている単位

- Light Client は複雑に見えるが、ヘッダーを再帰的に検証し、検証済みヘッダーの Merkle root を使用して目的のトランザクション/状態を検証するという単純な原則を備えている

### ヘッダー検証

- ヘッダーは Merkle Root がある限り、トランザクションと状態を検証できる

#### PoW の場合

1. 以前の Hash, タイムスタンプ, フォーマットの基本情報を確認
2. Header の Nonce を確認して PoW を完成させる

- Transaction や State の確認の不要

#### PoS の場合

1. 以前の Hash, タイムスタンプ, フォーマットの基本情報を確認
2. バリデータセットの情報を確認
3. Vote を確認する
4. それらの Vote がシェアの 2/3 を超えているかどうかを確認する

- PoS では、状態の一部である、「バリデーターセット」が必要となる

### アルゴリズム

- Light Client が Transaction または状態を検証するためには、周囲のフルノードに`merkle proof`を要求し、検証済みヘッダーの`merkle root`を使用して検査する
- よって、ヘッダーも検証する必要があるのだが、ヘッダーは`前のブロックのHash`を含んでいるおり、これは前のブロックのヘッダーを検証することによってのみ知ることができる
- さらに、`バリデータ セット情報` は前のブロックの状態を検証することによってのみ知ることができる
- 対象のヘッダーを検証するために必要な前のブロックに関する情報を検証するには同じ方法を使用して再帰的に検証する必要がある

### PoW の Light Client

- ヘッダーに`merkle root`が含まれていれば可能となる

1. ブロックヘッダーの取得

   - ノードは、検証したいトランザクションを含むブロックのヘッダー`H`を取得。
   - 周囲の他のノードに取得を依頼するか、ローカル コンピューターにあるまだ検証されていないノードを選択することができる。

2. `H` が既に検証されているかどうかの確認

   - `H` が既に検証されている場合は、`Step 6` に進む。
   - 検証済みの `H` を `H'` とすると、これは`H` が 以下の場合に発生する可能性がある
     - Genesis ブロックのヘッダー
     - ノードが以前に検証したヘッダー
     - または信頼できるノードによって提供されたヘッダー

3. `H` の前のヘッダー`H_p`を受け取る。

   - ここからが、ヘッダーの検証手順

4. `H_p` は、これらすべてのプロセスの再帰によって検証され、これを `H_p'` と呼ぶ

   - 前述のように、Light Client の検証プロセスは帰納的(誘導的) [inductive]
   - 対象のヘッダーを最終的に検証するには、前のヘッダーを検証する必要がある。
   - これは、手順 1 ～ 6 の再帰によって解決可能
   - (基本ケースは `Step 2` を参照)

5. `H_p'` を使用して `H` を検証する

   - 前のヘッダーでヘッダーを検証する方法は、上記のとおり
     1. 前のハッシュを含むヘッダーの基本情報を検証し、
     2. PoW の結果であるナンスを検証する。
   - この場合、「前のハッシュ」を把握するために `H_p` が必要となる

6. ノードが最初に確認したいトランザクション/状態を含むブロックのヘッダーが 検証済み`H'`かどうかの確認

   - 既にヘッダーが確認済みの場合は `Step 7` に進む。
     - これは、再帰プロセスを完了した後、スタックの一番上にいることを意味する
   - そうでない場合は、再帰を `Step 4` に戻す。

7. ノードが検証したいトランザクション/状態 `T` を検証する

   - これは、`T` が実際にブロックで使用されているかどうかを確認することを意味する
   - `T` が存在するブロックの証明されたヘッダー `H'` が既に存在する
   - `T` を検証するために必要な`Merkle proof` (Merkle root へのパス上に存在する他のノード) をフルノードに要求する

8. 現在表示しているチェーンが最長のブロックチェーンであるかどうかを確認

   - PoW は、最も長い (計算量が最も多い) チェーンに同意する
   - Light Client が見ているのは、正確にはブロックチェーンではなく、一連のヘッダー
   - しかし、チェーンヘッダーの長さを確認するだけで、実際に合意された最長のブロックチェーンのヘッダーであることを確認できる

9. `T` とその`Merkle proof`を計算して、`H'` で記述された`Merkle root`と同じかどうかを確認する

### PoS の Light Client

- PoS の Light Client は PoW よりも複雑で、ヘッダーの検証のために、以前のヘッダーだけでなく、以前の状態も検証する必要がある

![PoS Overview](https://raw.githubusercontent.com/hiromaily/documents/main/images/PoS.png 'PoS')

- ヘッダー、トランザクション、State
  - ブロックチェーン構造の一部で、PoW, PoS 共に存在する
- Votes
  - PoS のバリデーターによって署名される
  - ブロックは Stake を持つバリデーター(参加者)の Vote によって Confirm される
  - Tendermint アルゴリズムでは`pre-commit`と言われる
  - Chain によっては、次のブロックヘッダーで Vote を保持するが、実装の詳細にすぎない
- Voting の動作

  - この時点までのヘッダーの Vote に関する累積情報
  - `バリデータ セット`の動作を抽象化する一連の情報であり、実装には実際には存在しない可能性がある。
    - たとえば、CodeChain は、一定期間投票に参加していないバリデーターに、その期間中の累積ヘッダー (Voting 情報を含む) から推定されるポリシーを送信する
    - ただし、レポートなどの特別なアクションは、ここではなくトランザクションに含まれる場合がある

- 矢印の意味
  - Previous hash
    - ブロック全体のハッシュがあることを示す
    - PoW と同じくヘッダーを検証するために必要
  - Merkle tree
    - マークル木が構成され、そのルートが書かれていることを示す
    - PoW と同様に、ヘッダーで確認したい情報には、この繋がりが必要
  - Proves validness
    - PoS で必要な追加のステップ
    - コミットされたブロックに同意したバリデーターの情報を検証するために必要な依存関係を示す
  - Deduces(推測)
    - 矢印の入力だけで矢印の出力を推測できることを示す
    - 例えば、すべてのヘッダー (バリデーターの投票 status 情報)、トランザクション、および前の State から、次の状態を推測することができる
    - ただし、LightClient は、FullNode から次の pre-deduced の状態を取得し、それを Merkle proof で検証するだけでよい
    - 結果、LightClient はこの推定プロセスについてまったく知る必要はない
- データの分類 (点線部)
  - Current Step
    - ヘッダーが検証されることを示す
    - PoS も再帰的であるため、現在の再帰ステップを表している
  - You wanna verify these
    - ノードが実際に確認したいデータ
    - 確認するには、現在のステップに対応するヘッダーにある確認済みの Merkle root が必要
  - You need these
    - `previous hash`または`proves validness`
    - つまり、ヘッダーを検証するために最初に検証する必要があるもの

#### PoS のアルゴリズム (PoW と重なる部分は省略)

1. ノードは、検証するトランザクションを含むブロックのヘッダー`H`を取得する
2. `H` が既に検証済みかどうか
   - 検証済みの場合は、`Step 9` に進む
   - 検証済みの `H` は `H'` とする
3. `H` の前のヘッダー`H_p`を取得する
4. 前の状態の一部である`バリデータ セット` データ`S_p`を、FullNode から取得
   - これは、`H` に投じられた Vote の有効性と Stake を計算するために必要
   - これらの計算には、バリデーターのリストだけでなく、その mandates(権限)、ban status(禁止ステータス)、imprisonment records(投獄記録)も必要
5. `H` の Votes を集める (これは Tendermint でいう`pre-commit`で、ここでは`C`とする)
   - Voting は特定のブロックに対して行われ、秘密鍵で署名されているため、どのバリデーターがどのブロックに投票したかを改ざんすることはできない
   - これは、公開鍵と`vote summary`で簡単に確認できるため、どこから、誰から受け取ったかは問題ではない
   - 署名値、投票元 (またはそれを推測できる情報)、および投票者の公開鍵を `C` として組み合わせると、`C` はそのまま検証される
   - 検証済みの`pre-commit`をこれを`C'`とする
   - CodeChain の場合、次のブロック ヘッダーに `C` を入れる (`C'`の記述ミス？)
   - 説明したように、`C` はその存在だけで検証されるため、ブロックが偽物であっても、ソースに対応する次のブロック ヘッダーを検証する必要はない (`C'`の記述ミス？)
   - (`C`はどこからでも取得できる。)
6. `H_p` は、これらすべてのプロセスの再帰によって検証される
   - 検証済み`H_p`を`H_p'` とする
7. `H_p'` を使用して `S_p`(前の状態の一部であるバリデーターセット) を確認する
   - これを `S_p'` とする
   - これは簡単で、ヘッダーにはステート全体に関する`Merkle root`が含まれているため、フル ノードから`Merkle proof`を取得して検証できる
8. `H_p'`、`S_p'`、および `C'` を使用して、`H` を検証する
   - 検証済みの`H`を `H'`とする
   - PoW と同様に、ヘッダーの基本情報と前のハッシュをチェックした後、`S_p'`と `C'` の組み合わせは、有効なバリデータ セットのメンバーが `H` に投票したことを検証し、カウントされた合計の 2/3 を超えていることを検証する
   - ここで重要なことは、各チェーンの staking rules を知る必要がないこと
   - これは、`S_p` がフル ノードによって提供され、これらの変更がすべて `H_p'` によって既に適用および検証されているため
9. 検証したいヘッダーが検証済みかどうか
   - ノードが最初に検証したいトランザクション/状態を含むブロックのヘッダーが `H'` である場合は、`Step 10` に進む
   - そうでない場合は、再帰を`Step 6` に戻す
10. ノードが検証したいトランザクション/状態を `T` とする。最後のステップで、`T` を検証するために必要な`Merkle proof`を完全なノードに要求する
11. `T` とその`Merkle proof`を計算して、それが `H'` に書かれた`Merkle root` と同じかどうかを確認する

#### 上記のアルゴリズムについて考慮すべきこと

- 再帰ステップの最大量は、他のフルノードが保存する過去の状態の量に依存するということ
- 実装に応じて、ノードはすべてを保存し続けることも、特定のポイントより前のブロックを消去することもできる
- 前者の場合、ジェネシスブロックまで再帰が発生しても、その時点での状態に関する情報を常に提供する準備ができている完全なノードがあるため、最後まで再帰を続行しても問題ない
- 一方、後者の場合、フルノードは過去の状態 `S_p` を特定のポイントまでしか保存しないため、範囲を超える前に、LightClient Node は以前に検証された `S_p'` を満たし、再帰を終了する必要がある
- つまり、LightClient が大きく遅れる前に、検証済みのローカル ヘッダー チェーンに新しいブロックを定期的に適用する必要がある
- 最悪の場合、すべてのフル ノードが古い状態をすぐに消去する場合、ライト ノードが新しいブロックのヘッダーを 1 回でも見逃すと、再び追いつくことができなくなる
- これは、再帰を複数回実行する必要があるためだが、それに応答する完全なノードはない

### Optimization

- LightClient は、ヘッダーのみを検証し、フルノードから残りを受け入れて`Merkle proof`を検証する、シンプルで高速かつ軽量なソリューション
- しかし、さらに最適化できるとしたらどうか? おそらく、このプロセスで最もコストのかかる部分は、ヘッダーの手動検証になる
- これには、以前のヘッダーの再帰が必要で、再帰の深さは、適切な過去のヘッダーを提供する信頼できるノードがあるかどうか、または以前に検証済みのヘッダーがあるかどうかによって異なるが、最悪の場合、ジェネシスブロックまで遡る
- このプロセスをすばやくスキップすることが、最適化の主な目標となる
- この点に関して、PoS に適用できる 2 つの手法を紹介する

1. 最初のステップ: チェックポイントを作成すること

   - プロトコルの設計によってブロックが頻繁に作成される場合は、各ブロックの後に設定されたバリデータを変更せずに一定期間を過ごすことができる
   - そのポイントは「チェックポイント」と呼ばれ、チェックポイントにはさらに、前のチェックポイントのハッシュと次のチェックポイントのバリデータ セット情報を含めることができる
   - その後、LightClient はチェックポイント間をジャンプできる
   - たとえば、100 ブロックごとにチェックポイントがあり、関心のあるヘッダーがブロック 412 である場合、ジェネシス ブロックからチェックポイント 400 までの 4 つのチェックポイントを検証し、12 ブロックのそれぞれを 1 つずつ検証する。このプロセス全体は、412 回よりもはるかに少ない 16 回の検証で終了する

2. 2 番目のステップ: 検証済みのヘッダー バリデータ セットを信頼し、検証プロセスを完全にスキップすること

   - PoW では、間違ったチェーンに参加した場合のペナルティは、CPU 計算の浪費であり、それ以上のものではない
   - 一方、PoS では、間違ったチェーンに参加すると、メイン チェーンのデポジットが実際に失われる
   - このプロセス中にこれを報告したユーザーは、一定の報酬を受け取る
   - この機能により、間違ったブロックを見ているというリスクを冒すだけで、異常な最適化が可能になる
   - たとえば、すでに検証済みのヘッダー H1 があり、H2 を検証したいとする
   - H1 のバリデーターセットと H2 の投票したバリデーターの間に大きな違いがない場合、H2 のバリデーターセットのリストは既に検証済みであると見なすことができる
   - H2 の有効なバリデータ セットがわからないため、H2 で投じられた投票が有効かどうかはわからない
   - ただし、投票参加者が H1 のバリデーターセットと類似している場合 (Tendermint チームが提案した標準は 1/3 未満の変更)、H2 に投じられた投票のほとんどは、おそらく既に投票された H1 のメンバーからのもの
   - 検証され、実際に預金を支払った人であることを知ることができるので（もちろん、預かった期間の問題もあります。）、リスクがあっても、本当に間違っていれば、そこに投票したほとんどの人は、預金も失う
   - もちろん、運が良ければ、最初に報告することで報酬を受け取ることができる。
   - したがって、スピードが重要な場合は、誰もがあなたを欺くためだけにデポジットを支払ったわけではないという信頼の下で、この最適化を実装できる

   - さらに、H1 と H2 のバリデータ セット間に大きな不一致がある場合は、それらの間の別のブロックの H3 をバイナリ除算による踏み台として選択できる
   - もちろん、H1 と H3、または H3 と H2 の差が大きい場合は、このギャップを再帰的に最小化できる

## Tendermint

- [Light Client](https://docs.tendermint.com/v0.34/tendermint-core/light-client.html)
- [Go Package](https://pkg.go.dev/github.com/tendermint/tendermint/light)
