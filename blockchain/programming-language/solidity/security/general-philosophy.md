# [Ethereum Smart Contract Security Best Practices: General Philosophy](https://consensys.github.io/smart-contract-best-practices/general-philosophy/)

- [The Smart Contract Security Field Guide for Developers](https://scsfg.io/developers/)を参照とのこと

スマート・コントラクトのプログラミングには、これまでとは異なるエンジニアリングの考え方が必要。失敗のコストは高く、変更は難しく、ある意味ではウェブやモバイルの開発よりも、ハードウェアのプログラミングや金融サービスのプログラミングに似ている。そのため、既知の脆弱性を防御するだけでは不十分で、その代わりに、新しい開発哲学を学ぶ必要がある

## 失敗に備える

自明でない契約にはエラーがつきものだ。したがって、あなたのコードは、バグや脆弱性に優雅に対応できなければならない。

- 物事がうまくいかないときに Contract を一時停止する（circuit breaker）
- リスクのある金額を管理する（rate limiting, maximum usage）
- バグフィックスや改良のための効果的なアップグレードパスを持つ

## 最新情報

新しいセキュリティの動向を把握する

- 新しいバグが発見され次第、Contract をチェックする
- ツールやライブラリはできるだけ早く最新バージョンにアップグレードする
- 有用と思われる新しいセキュリティ技術を採用する

## シンプルに

複雑さはエラーの可能性を高める。

- Contract ロジックがシンプルであること
- コードをモジュール化して、コントラクトと関数を小さく保つ
- 可能な限り、すでに書かれているツールやコードを使う（例：乱数発生器を自作しない）
- 可能な限り、パフォーマンスよりも透明性を優先する
- システムの分散化が必要な部分にのみブロックチェーンを使用する

## 初公開: Rolling out

本番リリースの前にバグを発見するのは、常に良いこと

- Contract を徹底的にテストし、新しい攻撃ベクトルが発見されるたびにテストを追加する
- アルファ版のテストネットリリースからバグ報奨金を提供する
- 段階的に展開し、各段階で Usage(使用量)とテストを増やす

## ブロックチェーンの特性

あなたのプログラミング経験の多くはイーサリアムのプログラミングに関連するだろうが、注意すべき落とし穴もある。

- 悪意のあるコードを実行し、制御フローを変更する可能性のある外部コントラクト呼び出しには細心の注意を払うこと。
- パブリック関数は公開され、悪意を持ってどのような順序でも呼び出される可能性があることを理解する
  - スマート・コントラクトの private data も、誰でも見ることができる。
- gas cost と block gas の制限を念頭に置く
- ブロックチェーン上のタイムスタンプは不正確であり、マイナーは数秒の差で取引の実行時刻に影響を与える可能性があることに注意する
- ブロックチェーン上ではランダム性は自明ではなく、乱数生成のほとんどのアプローチはブロックチェーン上でゲーム可能である。

## 単純さと複雑さ

スマートコントラクトシステムの構造とセキュリティを評価する際に考慮すべき複数の基本的なトレードオフがある。スマート・コントラクト・システムの一般的な推奨事項は、これらの基本的なトレードオフの適切なバランスを特定すること

ソフトウェア工学のバイアスに立った理想的なスマートコントラクトシステムは、モジュール化されており、コードを複製する代わりに再利用し、アップグレード可能なコンポーネントをサポートしている。特に複雑なスマートコントラクトシステムの場合、セキュアアーキテクチャのバイアスから見た理想的なスマートコントラクトシステムは、この考え方を共有するかもしれない。

しかし、セキュリティとソフトウェア工学のベストプラクティスが一致しない重要な例外も存在する。いずれの場合も、適切なバランスは、以下のような Contract システムの次元に沿った特性の最適な組み合わせを特定することによって得られる：

- 堅牢性とアップグレード可能性 (Rigid versus Upgradeable)
- モノリシックとモジュラー (Monolithic versus Modular)
- 複製と再利用 (Duplication versus Reuse)

### Rigid versus Upgradeable

このリソースを含む複数のリソースは、Killable（殺害可能）、Upgradeable（アップグレード可能）、Modifiable（変更可能）といったパターンのような可鍛性(Malleability)の特性を強調しているが、可鍛性(Malleability)とセキュリティの間には基本的なトレードオフがある。

可鍛性パターンは定義上、複雑さと潜在的な攻撃面を追加する。スマート・コントラクト・システムが、あらかじめ定義された限られた期間、非常に限定された機能セットを実行するような場合、例えば、ガバナンスのない有限時間枠のトークンセール・コントラクト・システムなどでは、複雑さよりも単純さの方が特に効果的。

### Monolithic versus Modular

モノリシックな自己完結型のコントラクトは、すべての知識をローカルで識別可能かつ読み取り可能な状態に保つ。一枚岩として存在するスマート・コントラクト・システムが高く評価されることは少ないが、例えばコード・レビューの効率を最適化する場合など、データとフローの極端な局所性を求める議論もある。

ここで検討した他のトレードオフと同様に、セキュリティのベストプラクティスは、単純な短期契約の場合はソフトウエアエンジニアリングのベストプラクティスから遠ざかり、より複雑な永久 Contract システムの場合はソフトウエアエンジニアリングのベストプラクティスに向かう傾向がある。

### Duplication versus Reuse

ソフトウェアエンジニアリングの観点からスマートコントラクトシステムは、合理的な再利用を最大化したいと考える。Solidity でコントラクト コードを再利用する方法はたくさんある。一般的に、コードの再利用を達成するための最も安全な方法は、自分が所有している実績のある以前にデプロイされたコントラクトを使用すること。

複製は、自己所有の以前に展開されたコントラクトが利用できない場合に、頻繁に頼られる。OpenZeppelin の Solidity ライブラリのような取り組みは、安全なコードが重複することなく再利用できるようなパターンを提供しようとするもの。コントラクトのセキュリティ分析には、対象となるスマートコントラクトシステムのリスクに見合った信頼レベルを以前に確立していない再利用コードを含める必要がある。
