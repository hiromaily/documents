# Solidity Storage

- [ストレージ内の状態変数のレイアウト](https://solidity-ja.readthedocs.io/ja/latest/internals/layout_in_storage.html)
- [メモリ内のレイアウト](https://solidity-ja.readthedocs.io/ja/latest/internals/layout_in_memory.html)

```
pragma solidity >=0.4.16 <0.9.0;

contract SimpleStorage {
    uint storedData;

    function set(uint x) public {
        storedData = x;
    }

    function get() public view returns (uint) {
        return storedData;
    }
}
```

## ストレージ内の状態変数のレイアウト まとめ

- Solidityでいうコントラクトとは、Ethereumブロックチェーン上の特定のアドレスに存在するコード（functions）とデータ（state: global変数）の集合
- `uint storedData;` という行は、 uint型の storedData という`状態変数`を宣言している
- これは、データベースを管理するコードの関数を呼び出すことで問い合わせや変更ができる、データベースの1つの`スロット`

- コントラクトの`状態変数`は`ストレージ`にコンパクトに格納され、複数の値が同じ`ストレージスロット`を使用することがある
- ストレージの`スロット`は、`256ビット（32バイト）`の長さを持つキーと値のペアとして格納されている
- 各スロットのデフォルト値は常に`0`
- ストレージには変数だけが格納され、定数は格納されない
- 各スロットは最大256ビット（32バイト）格納可能
- 動的なサイズの配列やマッピング（後述）を除き、データはスロット`0`に格納された最初の状態変数から順に連続して格納される
- 各変数には、その型に応じてバイト単位のサイズが決定される
- `32バイト`に満たない複数の連続したアイテムは、以下のルールに従って、可能な限り1つのストレージスロットにまとめられる
  - 変数は順番に下位から（つまり右から左へ）スロットに格納される
  - 変数のサイズがスロットの残りサイズを超えると、この変数は新しいスロットに渡される
  - `Struct`, `固定サイズ配列`, は新しいスロットを作成する
  - `動的サイズ配列`は新しいスロットを作成する
  - このスロットには配列の長さだけが格納され、配列内の値は他の場所に格納される
  - `mapping`は常に場所を保持するために新しいスロットを作成し、配列の値は他の場所に格納される
  - `文字列`は新しいスロットを作成し、このスロットにはデータとデータ長の両方が格納される

## メモリ内のレイアウト まとめ

- Solidityは`4つ`の`32バイト`スロットを確保している
  - `0x00` - `0x3f` （64バイト）: ハッシュ化のためのスクラッチ領域
    - ステートメント間（インラインアセンブリ内）で使用できる
  - `0x40` - `0x5f` （32バイト）: 現在割り当てられているメモリサイズ（別名: フリーメモリポインタ）
    - Solidityは常に新しいオブジェクトをフリーメモリポインタに配置し、メモリは解放されない
  - `0x60` - `0x7f` （32バイト）: ゼロスロット
    - 動的メモリ配列の初期値として使用され、決して書き込まれてはならない

- メモリ上のレイアウトと ストレージ 上のレイアウトは異なる

## solidity assembly

- ストレージにデータを書き込む際に、インラインアセンブリでデータサイズを意識しながら書き込むことで、ガスを節約することが可能になる
