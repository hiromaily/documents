# docker `exec`と`run`の違い

## `docker run`

### `docker run`の用途

`docker run`コマンドは、新しいコンテナを起動し、その中で指定されたコマンドを実行するために使用される。

### `docker run`の特徴

1. **新しいコンテナの起動**:

   - 新しいコンテナを作成し、そのコンテナ内で指定されたコマンドを実行する。
   - コンテナのライフサイクルがコマンドの実行に依存する。コマンドが終了すると、コンテナも終了する。

2. **コンテナの設定**:

   - `-v` オプションでボリュームをマウントしたり、`--network` オプションでネットワークを設定できる。
   - 環境変数、ホスト名、ポートマッピングなども指定可能。

3. **新しいインスタンスの作成**:
   - 毎回新しいコンテナインスタンスを作成する。既存のコンテナには影響を与えない。

### `docker run`の例

```sh
# 新しいコンテナを起動して、ホストのカレントディレクトリをコンテナの/backupにマウントし、mysqldumpコマンドを実行
docker run --rm -v $(pwd):/backup --network communication-hub-network mysql:8.0 sh -c 'mysqldump -h my-db -u root -ppassword --no-data my-db > /backup/schema.sql'
```

## `docker exec`

### `docker exec`の用途

`docker exec`コマンドは、既に実行中のコンテナ内で新しいコマンドを実行するために使用される。

### `docker exec`の特徴

1. **既存のコンテナでのコマンド実行**:
   - 既に起動しているコンテナ（ライブコンテナ）の中でコマンドを実行する。
   - コンテナのライフサイクルは変更されない。コンテナはコマンドの前後で起動し続ける。

2. **ライブデバッグと管理**:
   - コンテナ内で対話的にシェルを起動してデバッグしたり、管理タスクを実行できる。
   - 例えば、コンテナにアクセスしてファイルを確認したり、追加でパッケージをインストールしたりする時に便利。

3. **設定の継承**:
   - コンテナが既に設定されているネットワーク、ボリュームなどの設定をそのまま使用する。
   - 各種環境変数やユーザ設定も既存のコンテナから継承される。

### `docker exec`の例

```sh
# 既存のコンテナ内で、新しいbashシェルを起動
docker exec -it my-db bash
```

## 違いのまとめ

- **新しいコンテナ vs 既存のコンテナ**:
  - `docker run`は新しいコンテナを起動する。
  - `docker exec`は既存のコンテナ内でコマンドを実行する。

- **ライフサイクル**:
  - `docker run`はコマンドの実行と同時にコンテナのライフサイクルが始まり、終了する。
  - `docker exec`は既存のコンテナのライフサイクルに影響を与えない。

- **デバッグ用途**:
  - `docker run`は概ねバッチジョブとして一回限りの作業に使われる。
  - `docker exec`はライブデバッグや管理タスクに使われる。

`docker run`と`docker exec`は用途に応じて使い分けることが重要。例えば、新しいセットアップやデータ取得には`docker run`を使用し、既存のコンテナ内の簡単な調査や修正には`docker exec`を用いると効率良く作業を進めることができる。
