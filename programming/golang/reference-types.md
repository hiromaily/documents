# 参照型

参照型はは値そのものを直接持つのではなく、値への参照（ポインタやインターフェース）を保持する。
これらの変数を別の変数に代入すると、データそのものではなくデータへの参照（アドレス）がコピーされる。

1. **ポインタ（pointer）**: 値のメモリアドレスを保持する型。例えば、`*int` は `int` 型の値へのポインタ。
2. **スライス（slice）**: 配列の部分列への参照で、内部的にはポインタ、長さ、容量の情報を持っている。
3. **マップ（map）**: キーと値のペアを保持するハッシュテーブルのようなデータ構造。
4. **チャネル（channel）**: ゴルーチン間でデータを送受信するための通信手段。
5. **インターフェース（interface）**: 様々な具体型を実装できる型で、抽象化されたメソッドの集合を定義する。

これらの参照型は、値型と対比され、例えば構造体（struct）や基本型の数値、ブール値などとは異なる特性を持つ。参照型を使用する場合、値のコピーが発生せず、メモリ使用量やパフォーマンスに注意する必要がある。

## makeについて

makeは、動的に配列、スライス、マップなどの参照型を初期化（メモリを割り当てるため）に使用される。makeは、newとは異なり、ゼロ値で初期化された配列やスライスを作成する。
参照型以外は`new`で作成する。

| 呼び出し形式      | 型       | 意味                                            |
| ----------------- | -------- | ----------------------------------------------- |
| `make(T, n)`      | スライス | 要素数と容量がTであるT型のスライスを生成        |
| `make(T, n, m)`   | スライス | 要素数が n で容量が m であるT型のスライスを生成 |
| `make(T)`         | マップ   | T型のマップを生成                               |
| `make(T, n)`      | マップ   | T型のマップに要素数 n を付与                    |
| `make(chan T)`    | チャネル | バッファのないT型のチャネルを生成               |
| `make(chan T, n)` | チャネル | バッファサイズ n のT型のチャネルを生成          |

## スライス（slice）といった参照型のポインタ型に持つことのメリット

[Is it correct to use slice as *[]Item, because Slice is by default pointer](https://stackoverflow.com/questions/72978660/is-it-correct-to-use-slice-as-item-because-slice-is-by-default-pointer)

### 以下はChatGPTによって生成された回答だが、正しいかどうかは不明

特に、大きなデータ構造や共有状態を効率的に操作したい場合に有用

1. **効率的なメモリ使用**:
   - スライスのアドレスを持つことで、複数の変数間でムダなメモリコピーを避けることができ、大きなデータ構造を効率的に共有できる。これは特に大きな配列やバイナリデータを扱う場合に有用。

2. **可変性**:
   - スライスのアドレスを渡すことで、呼び出された関数の中でスライスの内容を変更できる。これにより、スライスの要素の追加や削除、データの変更などを元のスライスに反映させることができる。

3. **並行処理のサポート**:
   - スライスのアドレスを持つことで、複数のゴルーチン間でスライスを共有しやすくなる。これにより、並行処理を効率的に実現できる。ただし、この場合はアクセスの同期（例：ミューテックスなど）を行う必要がある。

4. **ポインタレシーバの利便性**:
   - メソッドレシーバとしてスライスのアドレスを使用する場合、スライスの内容を変更することができるため、メソッド呼び出し後にも変更が反映される。これにより、メソッド内で効率的にデータ操作が可能。

```go
package main

import "fmt"

func main() {
    // スライスのアドレスを渡す例
    s := []int{1, 2, 3}
    modifySlice(&s)
    fmt.Println(s)  // 出力: [1 2 3 4]
}

func modifySlice(s *[]int) {
    *s = append(*s, 4)
}
```
