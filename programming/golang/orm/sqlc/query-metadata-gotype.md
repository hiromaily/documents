# Sqlc クエリメタデータ `gotype`

`sqlc`のクエリメタデータで使用できる注釈の一つに`gotype`があり、この注釈を使うことで`クエリの結果を自分で定義したカスタム構造体にマッピングすることが可能`。これにより、クエリの結果をより柔軟に扱うことができる。

通常、sqlcはSQLクエリの結果を解析し、自動的に対応するGoの構造体を生成する。しかし、特定のデータモデルや特定の形式で結果を取得したい場合には、`gotype`を使ってカスタム構造体にクエリの結果をマッピングできる。

## `gotype`の使用方法

1. **カスタム構造体の定義**

まず、SQLクエリの結果に対応するカスタム構造体を定義します。構造体のフィールド名と型は、クエリの結果セットに対応する必要があります。

2. **SQLクエリファイルで`gotype`注釈の使用**

SQLクエリファイルにおいて、`gotype`注釈を使ってカスタム構造体名を指定します。

## `gotype`の具体例

以下に、具体的な例を示します。

### カスタム構造体の定義

まず、プロジェクト内に必要なカスタム構造体を定義します。

```go
package db

type UserInfo struct {
    ID    int32  `json:"id"`
    Name  string `json:"name"`
    Email string `json:"email"`
}
```

### SQLクエリファイルの記述

次に、SQLクエリファイルに`gotype`注釈を追加します。

**queries.sql**

```sql
-- name: GetUserInfo :one
-- gotype: UserInfo
SELECT id, name, email
FROM users
WHERE id = $1;
```

### sqlc.yamlの設定ファイル

`sqlc.yaml`では通常通り、スキーマファイルとクエリファイルを指定します。

**sqlc.yaml**

```yaml
version: "2"
sql:
  - engine: "postgresql"
    schema: "schema.sql"
    queries: "queries.sql"
    gen:
      go:
        package: "db"
        out: "db"
```

## コード生成

次に、sqlcを実行してGoコードを生成します。

```sh
sqlc generate
```

生成されたGoコードは次のようになります。

**db/queries.sql.go**

```go
// Code generated by sqlc. DO NOT EDIT.
// source: queries.sql

package db

import (
    "context"
    "database/sql"
)

type UserInfo struct {
    ID    int32  `json:"id"`
    Name  string `json:"name"`
    Email string `json:"email"`
}

func (q *Queries) GetUserInfo(ctx context.Context, id int32) (UserInfo, error) {
    row := q.db.QueryRowContext(ctx, getUserInfo, id)
    var i UserInfo
    err := row.Scan(&i.ID, &i.Name, &i.Email)
    return i, err
}
```

## カスタム構造体の使用

生成された関数を使ってクエリを実行し、結果をカスタム構造体にマッピングします。

**main.go**

```go
package main

import (
    "context"
    "database/sql"
    "log"

    _ "github.com/lib/pq"
    "example.com/myapp/db"
)

func main() {
    connStr := "user=username dbname=mydb sslmode=disable"
    dbConn, err := sql.Open("postgres", connStr)
    if err != nil {
        log.Fatal(err)
    }
    defer dbConn.Close()

    q := db.New(dbConn)
    ctx := context.TODO()

    userInfo, err := q.GetUserInfo(ctx, 1)
    if err != nil {
        log.Fatal(err)
    }

    log.Printf("User Info: %+v\n", userInfo)
}
```

このように、`gotype`注釈を使うことで、SQLクエリの結果をカスタム構造体にマッピングし、より柔軟なデータモデルを用いることができます。

## `gotype`の注意点

1. **構造体のフィールドとクエリ結果の一致**:
   - 構造体のフィールド名は、SQLクエリで取得するカラム名と一致する必要があります。
   - フィールドの型も適切にマッピングされる必要があります。

2. **構造体のスコープ**:
   - カスタム構造体は、`sqlc.yaml`で指定した出力パッケージ内に定義します。そうでない場合、適切にパッケージインポートを設定する必要があります。

3. **エクスポートされた構造体の再利用**:
   - 他のクエリでも同じ構造体を再利用したい場合、全てのクエリで同じ`gotype`注釈を使うことができます。

`gotype`を適切に利用することで、プロジェクトのコードベースがより整然とし、メンテナンス性が向上します。これにより、SQLとGoコードの間のデータマッピングがシームレスになり、開発効率が向上します。
