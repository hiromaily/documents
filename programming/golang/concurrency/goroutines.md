# Goroutines

Goroutines は、Goプログラミング言語における軽量なスレッドの一種。Goroutinesを用いることで、簡単かつ効率的に並行処理を実装することができる。

## 基本概念

- **軽量なスレッド**:
  - Goroutinesは非常に軽量で、多くのGoroutinesを低コストで生成できる。OSスレッドに比べるとリソースの消費が少なく、数千から数十万のGoroutinesを容易に扱うことができる。

- **独立した実行**:
  - 各Goroutinesは独立して実行され、Goランタイムによってスケジューリングされる。ここでは、必要に応じてOSのスレッドにマップされる。

## 使用方法

Goroutinesを起動するためには、`go`キーワードを使う。

```go
package main

import (
    "fmt"
    "time"
)

func sayHello() {
    fmt.Println("Hello from goroutine")
}

func main() {
    go sayHello()
    fmt.Println("Hello from main")
    
    // メインGoroutinesが終了しないように一時停止
    time.Sleep(time.Second)
}
```

- `go sayHello()`は`sayHello`関数を新しいGoroutinesとして非同期に実行する。
- `time.Sleep(time.Second)`を使ってメインGoroutinesが終了する前に少し待つ。これをしないと、メインGoroutinesが終了してプログラムが終了してしまう。

## Goroutines）とOSのスレッド（Threads）の違い

### OSスレッドとは

OSスレッドは、オペレーティングシステムによって管理される並行実行単位。各スレッドは独自のスタックを持ち、メモリ空間やリソースを共有する。スレッドはその重さと生成のオーバーヘッド、特に以下の点でゴルーチンと異なる。

### ゴルーチンとOSスレッドの主な違い

1. **軽量性**
   - **ゴルーチン**: 非常に軽量。スタックサイズは小さく、デフォルトで数KBで始まり (デフォルトでは約2KB)、必要に応じて動的に拡張される。これにより、数千から数百万のゴルーチンを同時に実行することが可能。
   - **OSスレッド**: 生成コストが高く、デフォルトで数MBのスタックを持つ。大規模な数のスレッドを生成するのは非効率。

2. **スケジューリング**
   - **ゴルーチン**: Goランタイムによって管理される協調的なスケジューリングを行う。ランタイムがゴルーチンのスケジューリングを管理し、できるだけ効率的にCPUリソースを使用する。
   - **OSスレッド**: OSカーネルがプリエンプティブにスレッドをスケジューリングする。スレッドによって頻繁にコンテキストスイッチが発生し、オーバーヘッドが大きくなる。

3. **コンテキストスイッチ**
   - **ゴルーチン**: コンテキストスイッチのオーバーヘッドが小さい。ゴルーチンはGoランタイムが管理するため、最小限のリソースで実現できる。
   - **OSスレッド**: コンテキストスイッチにはCPUレジスタやメモリのスタック情報を保存・復元する必要があり、オーバーヘッドが大きくなる。

4. **スタック管理**
   - **ゴルーチン**: スタックは動的に拡張されるため、メモリの利用効率が高い。スタックサイズは必要に応じて自動的に増減する。
   - **OSスレッド**: スタックサイズが固定または制限されているため、大きな初期スタックサイズを確保する必要がある。結果としてメモリの無駄が多くなることがある。

5. **生成と破棄のコスト**
   - **ゴルーチン**: 生成と破棄が非常に低コストで高速。
   - **OSスレッド**: 生成と破棄にコストがかかり、これによりスレッドの大量生成は非効率になる。

### 実際の例

以下に具体的な例を示します。以下のコードを使用して、簡単にゴルーチンを生成し、ゴルーチンの軽量性を確認します。

```go
package main

import (
    "fmt"
    "runtime"
    "sync"
)

func main() {
    var wg sync.WaitGroup
    numGoroutines := 100000

    // 現在のゴルーチンの数を表示
    fmt.Println("Initial number of goroutines:", runtime.NumGoroutine())

    for i := 0; i < numGoroutines; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            // ここで何らかの処理を行う
        }()
    }

    // ゴルーチン生成後の数を表示
    fmt.Println("Number of goroutines after creation:", runtime.NumGoroutine())

    wg.Wait()
}
```

このプログラムは、100,000のゴルーチンを生成し、その数を表示する。ゴルーチンの生成が非常に低コストであることを実際に確認できる。
とはいえ、10万の同時実行で、`2kb * 100,000 = 200,000kb ≒ 200MB`消費する
