# スマートポインタ

スマートポインタは、ポインタのように振る舞うだけでなく、追加のメタデータと能力があるデータ構造であり、通常の参照以上の機能を持つ。
例えば、`参照カウント方式のスマートポインタ型`は、このポインタのおかげでデータに複数の所有者を持たせることができ、所有者の数を追いかけ、所有者がいなくなったらデータの片付けをしてくれる。
参照とスマートポインタにはもう 1 つ違いがあり、参照はデータを借用するだけのポインタであり、対照的に多くの場合、スマートポインタは指しているデータを所有する。

## スマートポインタ特徴

- スマートポインタは指しているデータを所有する
- スマートポインタが Deref と Drop トレイトを実装している
  - Deref トレイトにより、スマートポインタ構造体のインスタンスは、 参照のように振る舞うことができる
  - これにより、参照あるいはスマートポインタのどちらとも動作するコードを書くことができる
- 多くのライブラリに独自のスマートポインタがあり、自分だけのスマートポインタを書くことさえできる

## スマートポインタの具体的な例

- String
- Vec<T>
- ヒープに値を確保する`Box<T>`
- 複数の所有権を可能にする参照カウント型の`Rc<T>`
- `RefCell<T>`を通してアクセスされ、コンパイル時ではなく実行時に借用規則を強制する型の`Ref<T>`と`RefMut<T>`

## ヒープのデータを指す`Box<T>`を使用する

Box により、スタックではなくヒープにデータを格納することができる。スタックに残るのは、 ヒープデータへのポインタ。
使われる場面としては、

- コンパイル時にはサイズを知ることができない型があり、正確なサイズを要求する文脈でその型の値を使用する時
- 多くのデータがあり、その所有権を移したいが、その際にデータがコピーされないようにしたい時
- 値を所有する必要があり、特定の型であることではなく、特定のトレイトを実装する型であることのみ気にかけている時

## `Rc<T>`は、参照カウント方式のスマートポインタ

複数の所有権を可能にするため、Rust には`Rc<T>`という型があり、これは、`reference counting(参照カウント)`の省略形。`Rc<T>`型は、値がまだ使用中かどうか決定する値への参照の数を追跡する。値への参照が 0 なら、どの参照も無効にすることなく、 値は片付けられる。

使うべき場面は、**ヒープにプログラムの複数箇所で読む何らかのデータを確保したいけれど、 コンパイル時にはどの部分が最後にデータを使用し終わるか決定できない時に `Rc<T>`型を使用する。** どの部分が最後に終わるかわかっているなら、 単にその部分をデータの所有者にして、コンパイル時に強制される普通の所有権ルールが効果を発揮する。

`Rc<T>`は、シングルスレッドの筋書きで使用するためだけのものであり、マルチスレッドプログラムにおいては、[`Arc<T>`](https://doc.rust-jp.rs/book-ja/ch16-03-shared-state.html#arct%E3%81%A7%E5%8E%9F%E5%AD%90%E7%9A%84%E3%81%AA%E5%8F%82%E7%85%A7%E3%82%AB%E3%82%A6%E3%83%B3%E3%83%88)を使う。

`Rc<T>`を clone すると、参照カウントが増える

## References

- [The Rust Programming Language 日本語版: スマートポインタ](https://doc.rust-jp.rs/book-ja/ch15-00-smart-pointers.html)
- [The Rust Reference: 10.Type system > Pointer types](https://doc.rust-lang.org/reference/types/pointer.html#smart-pointers)
  - References
  - Raw pointers
  - Smart Pointers
