# OAuth2.0

OAuth 2.0（Open Authorization 2.0）は、リソース所有者（User）とリソースサーバー（APIサービス）間で信頼できる方法でアクセス権を付与・管理するためのオープンスタンダードの`認可`フレームワーク。これにより、ユーザーのパスワードを共有せずにアプリケーション間で情報や機能へのアクセスを安全に許可することが可能。

## 利用されるシナリオ

- ユーザーがソーシャルメディアアカウントで別のサービスにログインする場合
  - （例：FacebookやGoogleアカウントで他のWebアプリケーションにログインする）
- スマートフォンアプリがバックエンドサーバに安全にアクセスするためのトークンを取得する場合

## 基本的なコンポーネント

1. **リソース所有者（Resource Owner）**：データやリソース（例：ユーザー情報）を保有しているエンティティ（通常はユーザー）。
2. **クライアント（Client）**：リソースサーバーにアクセスするアプリケーション。クライアントはリソース所有者の代理として行動。
3. **認可サーバー（Authorization Server）**：リソース所有者の認証仲介役であり、アクセストークンの発行管理も行う。
4. **リソースサーバー（Resource Server）**：保護されたリソース（APIなど）にアクセス提供するサーバー。認可サーバーによって発行されたアクセストークンを用いてリクエストを許可。

## 認可グラントタイプ（Authorization Grant Types）

OAuth 2.0では、さまざまなシナリオに対応するため、いくつかのグラントタイプが定義されている。

1. **認可コードグラント（Authorization Code Grant）**：
   - 最も一般的で安全なフロー。
   - リソース所有者が認可サーバーを通じてクライアントにアクセス権を付与。
   - クライアントは認可コードを受け取り、それを使用してアクセストークンを取得。

2. **インプリシットグラント（Implicit Grant）**：
   - シングルページアプリケーション（SPA）やクライアント側でのみ動作するアプリケーションのため。
   - 認可コードを取得するプロセスを短縮し、直接アクセストークンを返す。
   - セキュリティ上の理由から推奨されなくなりつつある。

3. **リソースオーナーパスワードクレデンシャルグラント（Resource Owner Password Credentials Grant）**：
   - リソース所有者のパスワード情報をクライアントに直接渡す。
   - トラストモデルが適用できる場合に限られる。一般的には非推奨。

4. **クライアントクレデンシャルグラント（Client Credentials Grant）**：
   - 機械間通信（Machine-to-Machine）のためのフロー。
   - クライアント自身がリソースアクセスを必要とする場合。

## フローの流れ（認可コードグラントの例）

1. **ユーザーの認証と認可**: ユーザーがクライアントを通じてリソースにアクセスしようとする。クライアントは認可サーバーにリクエストを送る。
2. **認可コードの発行**: 認可サーバーはユーザーを認証し、その後クライアントに認可コードを発行。
3. **認可コードの交換**: クライアントは認可コードを受け取り、認可サーバーにアクセストークン取得リクエストを送る。
4. **アクセストークンの発行**: 認可サーバーは認可コードを確認し、アクセストークンを発行、クライアントに返す。
5. **APIリクエスト**: クライアントは取得したアクセストークンを使用してリソースサーバーにAPIリクエストを送る。リソースサーバーはアクセストークンを検証し、リクエストを許可。

## トークンのタイプ

- **アクセストークン（Access Token）**：有効期限を持つ短期間のトークン。リソースサーバーにアクセスするために使用。
- **リフレッシュトークン（Refresh Token）**：長期間有効なトークン。アクセストークンの期限切れ後、新しいアクセストークンを取得するために使用。

## ソーシャルログインの典型的なフロー

ソーシャルログインの場合、Googleアカウントでのログインが成功しただけでは、自動的に利用しているサービスへのログインが許可されるわけではない。OAuth 2.0は、ユーザーの明示的な許可を得てリソースや情報へのアクセスを提供することを目指しているため、いくつかのステップが必要。

Googleアカウントでのログイン成功自体が利用しているサービスへのログインを即確定するわけではなく、ユーザーのデータにアクセスし、それを基にサービス内のアカウント管理を行う必要がある。これにより、ユーザーの情報とプライバシーが保護されつつ、シームレスなログイン経験が提供される。

`ソーシャルログインのみでセキュアな認証が可能`

1. **ユーザーの認可要求**
   - ユーザーがあなたのサービスにログインしようとすると、Googleの認証ページ（認可サーバー）にリダイレクトされる。ここで、ユーザーはあなたのサービスがGoogleアカウント情報へのアクセスを許可するかどうかを選択する。

2. **認可コードの受け取り**
   - ユーザーがアクセスを許可すると、Googleは認可コードをあなたのサービスにリダイレクトURIに含めて送る。

3. **認可コードの交換**
   - あなたのサービスが受け取った認可コードを使ってGoogleからアクセストークンを取得する。このリクエストには、クライアントIDとクライアントシークレット（事前にGoogleから取得しておく必要がある）が必要。

4. **アクセストークンでAPIにアクセス**
   - 取得したアクセストークンを使ってGoogleのAPIにリクエストを送り、必要なユーザー情報（例：メールアドレス、名前など）を取得する。

5. **ユーザーの認証とアカウント作成**
   - GoogleのAPIから取得したユーザー情報を使い、利用しているサービス内でユーザーの認証を行う。このとき、以下のような処理を行うことが一般的。
     - **ユーザーの識別**: Googleアカウントに関連付けられた一意なIDやメールアドレスを利用して、既存のユーザーアカウントがあるか確認。
     - **アカウント作成**: 未登録のユーザーであれば、新しいアカウントを作成し、Googleアカウントと関連付ける。このとき、パスワードの登録は必須ではない。

6. **サービスへのログイン処理**
   - あなたのサービス内で設定しているセッション管理の仕組みに従って、ユーザーをログイン状態に設定する。

### 注意事項

- **明示的な許可**: ユーザーが許可するアクセス権（スコープ）を明確に限定する。例：プロフィール情報、メールアドレスなど。
- **プライバシーポリシーの明示**: ユーザーがどの情報にアクセスされ、それがどのように使用されるかについて明確に説明する必要がある。
- **セキュリティ**: クライアントシークレットやアクセストークンを安全に管理する。アクセストークンの取得・管理においてhttpsを利用する。

### WIP: ソーシャルログイン の流れまとめ

前提条件として、`認可サーバー`はここでは、Google とする

1. Web サイトにアクセス
2. 「Google アカウントでログイン」をクリック
3. これにより、認可サーバー(Google)にリダイレクトされる
4. 未ログインの場合、Google のログイン画面が表示されるので、ログインする
5. ユーザーに、Google のリソース(情報)へのアクセスの認可を許可するかどうか確認する
6. 認可サーバーからアクセストークンが発行され、元の Web サイトにリダイレクトされる
7. また、アクセストークンを使って、Google のリソースにアクセスできる
