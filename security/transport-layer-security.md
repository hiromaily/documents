# Transport Layer Security (TLS)

[TLS wiki](https://ja.wikipedia.org/wiki/Transport_Layer_Security)

- セキュリティを要求される通信を行うためのプロトコル
- 主な機能として、

  1. 通信相手の認証、
  2. 通信内容の暗号化、
  3. 改竄の検出を提供

- コネクション型のトランスポート層プロトコル（通常は TCP）とアプリケーション層のあいだにおいて使われる
- TLS を導入さえすればセキュリティが確保できるという認識は誤っている
- TLS 通信は、平文での通信に比べて（主に暗号化・復号時）余分な計算機能力を使用するため、本当に必要なとき以外は使用しないことが多い

## 証明書の正当性

- 公開鍵証明書には認証局による電子署名が与えられる
- その署名の正当性を評価するためには認証局の証明書が必要であり、最終的にはルート証明書と呼ばれる一群の証明書に行きつく
- 各システムは、認証局の証明書として信用できるルート証明書を、あらかじめ保持している
- 認証局は自身の秘密鍵を厳重に秘匿し、また証明書の発行にあたっては正当なサーバ管理者かどうか確認することが求められる

- TLS で認証を行うためには、認証局の署名に加えて、証明書の発行先を確認する必要がある
- **TLS 用のサーバ証明書には発行先サーバのホスト名が書き込まれており、クライアントは自分が接続しようとしているサーバのホスト名と一致するかどうか確認することができる**

- SSL サーバ証明書では「このサーバは正しいものですよ」というのを証明するに当たり、例えば対象のドメインが存在するかどうかをチェックしたり、運営する組織や企業をチェックするなど、その存在の確かさを誰かが身元保証する必要がある
- この身元保証が、SSL サーバ証明書の根幹です。この身元保証をする組織は「認証局」と呼ばれる
- では、その身元保証をする認証局自体の正しさは誰が保証するのか？
  - この場合、他の認証局がチェックをする場合もありますが、その場合もさらに上位の認証局のチェックが必要になる
  - 最終的にその証明書が行き着く場所がルート証明書です

## CIA (幅広いセキュリティの考え方に共通する)

- 気密性 (Confidentiality)
  - 情報が意図した相手以外に漏れていないことを示す
- 完全性 (Integrity)
  - 情報が誰にも改ざんされていないことを示す
- 可用性 (Availability)
  - 使用可能であると想定されている状況において使用したいときに使用できることを示す

## 脅威モデル (Threat Model)

1. なりすまし (Spoofing)
    - 誰かのふりをして、不正に情報に関与することを指す
2. データの改竄 (Tampering)
    - データの書き換えや破壊を指す
3. 否認 (Repudiation)
    - ある行為者が、自身がした振る舞いについて認めず、否定すること
4. 情報漏えい (Information Disclosure)
    - 情報漏えいは、見せることを意図していない相手に情報が漏れてしまうこと
5. サービス不能 (Denial of Service)
    - 大量のリクエストやデータを送信し、使用できない状態にすること
6. 権限の昇格 (Elevation of Privilege)
    - 本来はアクセス権限のないユーザーにアクセス権が与えられてしまうこと

## セキュアなデータ通信のための技術

- 多くの通信のプロトコルは平文でのやりとり
- データ通信のセキュリティでは以下の 4 点に気をつける
  1. 盗聴されてもデータが読めないようにする
  2. 改ざんされてもそれを検知できるようにする
  3. なりすましされてもそれに気づけるようにする
  4. 否認されないように、本人でしか送付できない情報形式にする

## 暗号化技術 - 共通鍵暗号方式と公開鍵暗号方式

1. 共通鍵暗号方式
    - データ送信者が共通鍵でデータを暗号化して受信者にわたす
    - 受信者は受け取った情報を共通鍵で復号化して読む
    - 鍵の受け渡しをどうするのか考慮が必要
    - 相手が変わるたびに別の鍵が必要になる
2. 公開鍵暗号方式
    - 暗号化する鍵と復号化する鍵が異なる
    - 送受信間で、暗号化アルゴリズムを先に決めておく
    - サーバー側で暗号化する鍵を公開しておく(公開鍵)
    - データ送信者はその公開鍵で暗号化して送信する
    - データ受信者は秘密鍵でデータを復号化する
    - つまり、サーバー側で公開鍵、秘密鍵を用意
    - クライアントに公開鍵を渡す
    - クライアント側が公開鍵でデータを暗号化してサーバーに送信
    - サーバーしか秘密鍵をもっていないので、そのサーバーしか読めない
    - デメリットは、暗号化と復号化の鍵が違うというアルゴリズムは計算するのに時間がかかる
3. **共通鍵暗号方式と公開鍵暗号方式の 2 つの方式を組み合わせたハイブリッド暗号方式がある**

- SSL プロトコルはこのハイブリッド暗号方式を採用している
  - 送信者は共通鍵でメッセージを暗号化する
  - 使用した共通鍵を受信側(サーバー)の公開鍵で暗号化し、暗号化したメッセージと一緒にサーバーに送信する
  - サーバーは自分の秘密鍵で共通鍵を取り出し、その共通鍵でメッセージを復号化する

## メッセージ認証符号 MAC(Message Authentication Code)

- `改ざん`の対策手法(セキュリティ技術)
- データの完全性を保証するためのもの
- 任意のデータ(メッセージ)と共通鍵を使って、MAC 関数を用いて計算した値をそのデータと合わせて送信する
- 受信側は受け取ったデータから同じ MAC 関数を使って計算を行い、出た結果と受け取った MAC 値を比較して等しいかチェックする

## デジタル署名

- `なりすまし`や`否認防止`の対策
- 公開鍵暗号方式の逆
- データの送信側の秘密鍵でデータを暗号化し送る
- 送られたデータは送信者の公開鍵で復号化し、誰でも読むことができるが、
  送信者の秘密鍵は送信者しか知らず、これによって送信者を特定する

## SSL では以下の 3 つの機能を提供する

- ハイブリッド暗号方式による情報の内容の暗号化
- MAC 関数による改ざん検知
- デジタル署名による通信相手の認証

## SSL 通信における 2 つのフェーズ

### 1. ハンドシェイク

1. 使用するアルゴリズムの合意
2. サーバーの認証
   - **サーバーは自身の公開鍵を含む証明書を送付する**
3. データ転送で使用する鍵の確立
4. ハンドシェイクが正しく行われたことの確認

### 2. データ転送

- 分割されたデータをそれぞれ暗号化し、フラグメント毎に検証用のヘッダーと MAC を付加する

## SSL 通信が適用される範囲

- SSL プロトコルは OSI 参照モデルのセッション層(第 5 層)に位置する
- SSL はそれより下位層は暗号化しない
- 一般的には UDP ではなく TCP パケット配送の信頼性に基づいて使用される

## SSL 通信の種類

- HTTPS
- FTPS
- SMTPS
- SSL-VPN

## SSL 通信以外のセキュリティプロトコル

- IPsec
  - セッション層よりも下位のネットワーク層で共通鍵暗号方式を採用している(よって、SSL より高速)
  - VPN などでよく利用される
- S/MIME
  - メールにデジタル署名を付加した上でメッセージを暗号化し、End to End での通信を保護する
- SSH
  - アプリケーション層で実装される暗号化方式

## SSL 通信の構築準備

## 証明書

- Web サイトが安全であることを外部に示す電子証明書

### 証明書の種類

1. ドメイン証明
2. 実在証明(法的な証明)(組織認証)
3. 実在証明(物理的な証明)(EV: Extended Validation)

### 自己証明書について

- 自己証明書では規格は正しくても証明品質には問題がある、そのため、以下方法をとる必要がある

#### 1. 第三者に証明してもらう -> パブリック認証局による証明書

- 証明してくれる相手として、「認証局」とよばれる期間がある
- 証明書のいくつかは、ブラウザなどの SSL 接続アプリケーションに同梱されている

#### 2. 身近な誰かに証明してもらう -> プライベート認証局による証明

- ブラウザに証明書リストさえ載っていれば、選ばれた機関ではなくても、警告の出ない証明書が発行できるようになる
  - 企業内のブラウザに初期設定で、企業内の認証局の自己証明書を登録しておく
  - ただし、イントラネット内等の閉じた環境では OK

## 証明書を作成する [重要]

1. まず自分の公開鍵と秘密鍵を作成する
2. 証明したい情報を準備
3. 公開鍵と合わせて CSR(Certificate Signing Request: 証明書署名要求) というデジタル署名のリクエストとなるデータを生成
4. その CSR を証明してもらいたい人の秘密鍵で署名してもらう

### 1. 自己証明書の作成手順

1. 秘密鍵を作成する
   - OpenSSL を使用
   - 暗号化アルゴリズム(RSA など)、鍵の長さを選択
2. 公開鍵を作成する
   - 公開鍵と秘密鍵はペアで作成される
   - 同じ秘密鍵からは同じ公開鍵しか作成されない
3. CSR を作成する
   - 証明したい情報(つまり Web サイトの情報)をまとめる
4. 証明書を作成する
   - 自己証明書なので、CSR から自分で証明書を作成する
   - 証明書の規格(SSL の場合は C.509 ベース)、証明書の有効期間の設定を行う
   - 自分の秘密鍵で CSR に署名すれば完成
   - 作成した証明書を web サーバーに設定する

#### 2. 認証局による証明書の作成手順

1. 秘密鍵を作成する
2. 公開鍵を作成する
3. CSR を作成する
4. 証明書を作成する
    - これは認証局で作成する
    - よって、認証局を選定する
    - 証明してほしい Web サイトの情報を登録する

## 公開鍵・秘密鍵

- Web サーバーで使用する暗号化・復号化のキー

## 暗号化アルゴリズム

- データ転送時に用いる暗号化・復号化のルール

### 共通鍵暗号化方式

1. AES (Sdvanced Encryption Standard)
2. ~~DES (Data Encryption Standard) / 3DES (TripleDES)~~
3. ~~RC4 (Rivest Cipher 4)~~

### 公開鍵暗号化方式

1. [ECDHE](https://www.ecdhe.com/) (Elliptic Curve Diffie-Hellman Exchange)
2. RSA
3. ~~DH/DSS~~

## SSL ライブラリ

- SSL プロトコルを実現する暗号化・復号化モジュール

1. OpenSSL
2. GnuTLS
3. NSS

## SSL を適用する範囲

- HTTPS のほうがパフォーマンスが悪い
- よって、なるべく SSL の範囲を少なくするほうがいい
- 一般的に Web サーバーよりも奥はファイアウォールで守られた領域で、決められたサーバーとポートにしかアクセスできないようになっているはずなので、その領域は対象外としたほうがいいケースが多い
- SSL の導入はパフォーマンスとのトレードオフ

## SSL 通信実装

### 1. 秘密鍵の作成

- サーバーは公開鍵によって暗号化された情報の復号化を行う
- 作成した秘密鍵は root ユーザー以外から参照できないようにする

```sh
openssl genrsa 2048 > /etc/httpd/conf/server.key
```

- RSA 秘密鍵の拡張子は、`.key`や`.pem`になることが多い
- 認証局において、サーバー証明証を作成する際にも、2048bit 以上の鍵長であることが最低条件
- 証明書作成時に、公開鍵情報がそこに input されるので、公開鍵については、SSL 環境構築時に、特別作成する必要はない

### 2. CSR の作成

- 秘密鍵を input に CSR を作成
- サーバーが公開鍵に署名をしてもらう際に送るメッセージが CSR

```sh
openssl req -new -days 365 -key /etc/httpd/conf/server.key > /etc/httpd/conf/server.csr
```

- `-days`オプションで証明書の有効期限の指定をすることができる。このオプションをつけないと、とても短い有効期間になってしまう

### 3. 証明書の作成

- CSR を基に証明書の作成依頼を行う

#### 1. 自己証明書

- サーバーの秘密鍵の正当性をそのサーバーの秘密鍵を使用して署名した証明書のこと

```sh
openssl x509 -req -signkey server.key < server.csr > server.crt
```

- 上記は key で署名をして、証明書`crt`ファイルを作成している

#### 2. パブリック証明書

- サーバー CSR を認証局に送付して認証局の持つ秘密鍵で署名してもらうことで、鍵の信頼性を担保してもらう

## 通信のチェック

- `tcpdump`コマンドでパケットキャプチャを取り、`WireShark`でそれを閲覧する

```sh
tcpdump -i eth1 -s 0 -w /tmp/dump_http.pcap prot 80
tcpdump -i eth1 -s 0 -w /tmp/dump_https.pcap prot 443
```

## Let’s Encrypt

[Let’s Encrypt](https://letsencrypt.org/)
