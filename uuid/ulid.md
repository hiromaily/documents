# ULID

`ULID（Universally Unique Lexicographically Sortable Identifier）`とは、UUID と同様に一意の識別子（ID）を生成するための規格だが、特定の利便性と読みやすさを提供するために設計されている。特に、ULID は`辞書順にソート可能`であるという点が大きな特徴。
ULID は、UUID のユニーク性を保ちつつも、さらにいくつかの利便性を提供するために設計された識別子。高い一意性と並べ替え可能なことが特長。

[ulid: spec](https://github.com/ulid/spec)

## ULID の概要

ULID は、UUID の欠点を補完する形で以下の点に焦点を当てている：

1. **辞書順にソート可能**：タイムスタンプに基づいて生成されるため、生成時刻に従って簡単にソートできる。
2. **人間にとって読みやすい・覚えやすい**：英数字のみを使用し、特に URL やログなどでの扱いやすさが向上している。
3. **互換性**：`128 ビットの長さは UUID と同じ`なので、多くのシステムでの置き換えが容易。

## ULID の構造

`ULID は、26 文字の英数字で構成される`。各 ULID は以下の 2 つの部分に分かれている

1. **タイムスタンプ部分（10 文字）**：

   - Unix エポック時間に基づいてミリ秒単位で表現される。
   - 48 ビットの長さで、10 文字の英数字にエンコードされている。

2. **ランダム部分（16 文字）**：
   - 80 ビットのランダムなデータで構成され、16 文字の英数字にエンコードされている。

全体的なフォーマットは以下の通り：

```txt
01AN4Z07BY      JS9M4X3PQZBXKY  9YAD2J
│              │                │
└──────────────┴─────────────────┘
     10文字のタイムスタンプ部分     16文字のランダム部分
```

## ULID の生成

ULID は以下の手順で生成される：

1. **タイムスタンプ部分の生成**：

   - 現在の Unix タイムスタンプ（1970-01-01 からのミリ秒数）を取得する。
   - これを 48 ビットの整数として扱い、10 文字の英数字にエンコードする。

2. **ランダム部分の生成**：
   - 80 ビットのランダムなデータを生成する。
   - これを 16 文字の英数字にエンコードする。

## エンコーディング

ULID のエンコーディングには、以下の 32 の英数字が使われる：

```txt
0123456789ABCDEFGHJKMNPQRSTVWXYZ
```

このセットは、視覚的に似ている文字（例えば、'I'と'1'や'O'と'0'）が含まれていないため、人間による読み取りミスを減らす工夫がされている。

## ULID の利点

1. **辞書順ソート**：タイムスタンプに基づいているため、自然な順序でソートが可能。ログファイルやデータベースエントリの整理に便利。
2. **可読性**：英数字のみで構成され、特殊文字が含まれないため、人間にとって扱いやすい。
3. **エンコードおよびデコードが容易**：ULID の生成と利用が簡単で、各種プログラミング言語での実装も容易。

## 主な使用例

- データベースの主キー
- ログファイルのエントリの識別
- 分散システムでの一意識別子

## ULIDの標準化(Standardization)の状況について (2024/10)

WIP

## [ULIDが適さないかもしれないシナリオ](https://json-server.dev/ulid-not-to-be-used-scenarios/)

**ULIDの概要**
ULID（Universally Unique Lexicographically Sortable Identifier）は、UUIDの代替として人気が高まっている。ULIDは、48ビットのタイムスタンプと80ビットのランダムコンポーネントから成る128ビットの識別子で、可読性とソート可能性を提供する。

**ULIDが適さないシナリオ**
以下の状況では、ULIDの使用が推奨されない。

1. **高ボリューム書き込みシステム**
   - 大量のデータストリームやリアルタイムログを扱うシステムでは、ULIDのタイムスタンプが「ホットスポット」を生じ、データの不均一な分布を引き起こし、パフォーマンスのボトルネックを生む可能性がある。

2. **暗号的セキュリティ要件**
   - ULIDは一般的なユニーク性を提供するが、暗号的なセキュリティ基準を満たす設計ではない。機密性の高いアプリケーションには、暗号的に安全なUUID（バージョン4）などの使用が推奨される。

3. **UUID依存システムとの互換性**
   - 多くの既存システムはUUIDに基づいて構築されており、ULIDを統合すると互換性の問題が生じる可能性がある。特定のフォーマットを期待するライブラリやデータベースでは、ULIDが正しく処理されないことがある。

4. **ソートおよびインデックスの懸念**
   - ULIDはソート可能ですが、ランダムな分布が求められる場合には、タイムスタンプによるクラスタリングがパフォーマンスに悪影響を及ぼすことがある。このような場合、UUIDバージョン4のような完全にランダムな識別子が適している。

5. **レガシーシステムとの統合**
   - レガシーシステムにULIDを統合することは困難であり、既存のパターンやデータ構造に大きな変更が必要になることがある。このような場合、UUIDなどの既存の識別子形式を維持する方が実用的。

**代替案**
ULIDが適さない場合、以下の代替案を検討できる。

- **UUID**: バージョン4が広く使用されており、ランダム性を提供する。
- **Snowflake ID**: Twitterによって開発された64ビットのユニーク識別子で、高スループットのID生成に最適化されている。
- **その他のユニーク識別子システム**: 特定のニーズに応じて、カスタムまたはサードパーティの識別子システムを検討することができる。

ULIDは適切なユースケースで多くの利点を提供するが、特定のシナリオでは最適な選択ではないことを理解することが重要。

おそらく、UUID v7でも同じ問題があるのでは？

## UUID と ULID の比較

UUID と ULID のパフォーマンスに差があるかどうか（例えば、データベース操作やネットワークリソースの使用に関して）は、使用する具体的なシナリオによって異なる。

### UUID の特性

- **長さ**：128 ビット（16 バイト）
- **形式**：`32 桁の 16 進数`（8-4-4-4-12 の形式で表示されることが多い）
- **生成方法**：バージョンにより異なる（ランダム、タイムスタンプ、名前ベースなど）

### ULID の特性

- **長さ**：128 ビット（16 バイト）
- **形式**：`26 文字の英数字`
- **生成方法**：48 ビットのタイムスタンプと 80 ビットのランダム数

### パフォーマンスに関する考慮点

1. **識別子の長さとストレージ効率**：

   - UUID も ULID も 128 ビットの識別子なので、バイナリ形式ではどちらも同じサイズを占める。
   - 表示形式では、UUID は 32 桁の 16 進数であり、ULID は 26 桁の英数字。英数字エンコードの ULID は少し短いですが、`ストレージの観点から見ると、バイナリフォーマットで保存される場合はどちらも同じ`。

2. **ソートおよび検索性能**：

   - ULID はタイムスタンプに基づいているため、生成順に並べることができる。また、辞書順で簡単にソート可能。このため、挿入順序や時間に基づいたクエリには有利。
   - UUID はバージョンによって生成方法が異なり、v4 のランダム UUID では生成順に並べることができない (v7で解決済み)。ただし、UUID でもソートは可能だが、順序に意味がないためタイムスタンプが必要な場合などには追加のフィールドが必要。

3. **生成速度**：

   - UUID の生成速度はバージョンによりますが、多くのシステムでランダム UUID（バージョン 4）の生成は高速。
   - ULID の生成速度も非常に高速であり、特にタイムスタンプベースの部分生成とランダム部分生成が並行して行われるためパフォーマンスが良好。

4. **使用場面の適合性**：
   - UUID は広く互換性があり、標準化されているため、多くの既存システムやフレームワークでサポートされている。
   - ULID は特にタイムスタンプの順序が重要な場面で有利だが、`UUID ほど標準化されていないため、互換性が求められる場面では注意が必要`。

### 結論

ULID が 26 桁の表示形式を持つこと自体がパフォーマンス向上に直接繋がるわけではない。UUID と ULID のパフォーマンスや適合性を評価するには、使用する具体的なシナリオや要求に応じて考慮する必要がある。

- **データベースのソートやクエリ性能**：タイムスタンプに基づいた索引を多く使用する場合、ULID の方が有利。
- **生成速度**：これが特に重要でない限り、どちらも高速に生成可能。
- **一般的な互換性と標準化**：UUID が広く標準化されているため、互換性が重視される場面では UUID が有利。

## References

- [UUIDとULIDを理解していない方は見た方がいい記事](https://zenn.dev/kazu1/articles/e8a668d1d27d6b)
  - `プライマリキーには数値の自動採番を使用し、ユーザーに公開するキーとしては、別途ランダムな文字列（UUIDやカスタム乱数）を生成することで対処したら良い`と真っ当なことを言っている
- [内部Docs:DB のユニークキー](../database/uuid.md#db-のユニークキー)
