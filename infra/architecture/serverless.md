# Serverless Architecture

[ReadLater]

Serverless Architecture とは、開発者が基盤となるインフラを管理することなくサービスを構築・実行できるようにするソフトウェア設計のアプローチ。開発者はコードを書いてデプロイし、クラウド・プロバイダーはアプリケーション、データベース、ストレージ・システムを任意の規模で実行するためのサーバーを用意する。

## 仕組み

サーバーは、ユーザーがアプリケーションと通信し、そのビジネスロジックにアクセスすることを可能にするが、サーバーの管理にはかなりの時間とリソースを要する。チームはサーバーのハードウェアを保守し、ソフトウェアやセキュリティのアップデートを行い、障害に備えてバックアップを作成しなければならない。Serverless Architecture を採用することで、開発者はこれらの責任をサードパーティプロバイダーに委ねることができ、アプリケーションコードの記述に集中することができる。

最も人気のあるサーバーレスアーキテクチャの 1 つは、`FaaS（Function as a Service）` で、開発者はアプリケーションコードを個別の関数セットとして記述する。各関数は、電子メールの着信や HTTP リクエストなどのイベントによってトリガーされると、特定のタスクを実行する。通常のテスト段階を経て、開発者はトリガーとともに関数をクラウド・プロバイダーのアカウントにデプロイする。関数が呼び出されると、クラウド・プロバイダーは実行中のサーバー上で関数を実行するか、現在実行中のサーバーがない場合は、関数を実行するために新しいサーバーを立ち上げる。この実行プロセスは、アプリケーションコードの記述とデプロイに集中する開発者の視界から抽象化される。

![serverless](https://github.com/hiromaily/documents/raw/main/images/serverless-functions.avif "severless")

## 利用されているクラウドサービス

開発者の大半は FaaS プラットフォームである[AWS Lambda](https://aws.amazon.com/lambda/)を使ってサーバーレス・アプリケーションを構築しているが、Google と Microsoft もそれぞれ[Google Cloud Functions（GCF）](https://cloud.google.com/functions?hl=ja)と[Azure Functions](https://azure.microsoft.com/en-us/products/functions/)と呼ばれる独自の FaaS を提供している。

## 基本概念

クラウドプロバイダーによって使用する用語が異なったり、サーバーレス機能に独自の制限を設けたりすることがあるが、上記のリストは基本的な概念を定義していることに留意してほしい。

### Invocation: 召喚

単一の関数実行

### Duration: 期間

サーバーレス関数の実行にかかる時間。

### Cold Start: コールドスタート

ある関数が初めてトリガーされたとき、または一定期間使用されなかった後に発生する待ち時間。

### Concurrency Limit: 同時接続数制限

クラウドプロバイダーが定める、1 つのリージョンで同時に実行できるファンクションインスタンスの数。ファンクションはこの制限を超えるとスロットルされる。

### Timeout: タイムアウト

クラウド・プロバイダーが関数を終了させるまでに実行を許可する時間。ほとんどのプロバイダーは、デフォルトのタイムアウトと最大のタイムアウトを設定している。

## Serverless Architecture vs. Container Architecture

Serverless Architecture と Container Architecture はどちらも、開発者がホスト環境を抽象化してアプリケーションコードをデプロイすることを可能にするが、両者には重要な違いがある。例えば、Container Architecture を利用する開発者は、デプロイする各コンテナやそのシステム設定、依存関係を更新・保守しなければならない。対照的に、Serverless Architecture におけるサーバーのメンテナンスは、クラウドプロバイダーがすべて行う。さらに、サーバーレスアプリは自動的にスケールするが、Container Architecture のスケーリングには`Kubernetes`のようなオーケストレーションプラットフォームを使用する必要がある。

コンテナは、開発者が基礎となるオペレーティング・システムとランタイム環境をコントロールできるため、常に高いトラフィックが発生するアプリケーションや、クラウド移行の第一歩に適している。一方、`サーバーレス関数は、決済処理などのトリガーベースのイベントに適している`。

市場投入までの時間を最小限に抑え、スケーラブルで軽量なアプリケーションを構築したい企業は、サーバーレスから大きな恩恵を受けることができる。しかし、アプリケーションに継続的で長時間稼働するプロセスが多数含まれる場合は、仮想マシンやコンテナの方が良い選択かもしれない。ハイブリッド・インフラストラクチャでは、開発者はコンテナや仮想マシンを利用してリクエストの大部分を処理するが、データベース・ストレージなどの特定の短時間実行タスクはサーバーレス機能に任せることができる。

## 利点

近年、サーバーレスの採用が大幅に増加しており、世界中の企業の 40％近くが何らかの形でサーバーレスを利用している。小規模なスタートアップからグローバル企業までがサーバーレスアーキテクチャを活用している。

### コスト

クラウド・プロバイダーはインボケーションごとに課金するため、未使用のサーバーや仮想マシンに対して料金を支払う必要はない。

### スケーラビリティ

関数インスタンスは、トラフィックの変動に応じて、同時実行数の制限の範囲内で自動的に作成または削除される。

### 生産性

サーバーレスを利用するエンジニアは、サーバーを管理することなくコードをデプロイするだけで、デリバリー・サイクルを加速し、企業運営を迅速にスケールさせることができる。

## 課題

### コントロールの喪失

サーバーレス環境では、コードを実行するソフトウェア・スタックをコントロールできない。ハードウェアの故障やデータセンターの停止、その他の問題がサーバーのひとつに影響した場合、クラウド・プロバイダーに修理を依頼することになる。

### セキュリティ

クラウド・プロバイダーは、同じサーバー上で複数の顧客のコードを同時に実行する可能性がある。共有サーバーが適切に設定されていなければ、アプリケーションのデータが流出する可能性がある。

### パフォーマンスへの影響

サーバーレス環境ではコールドスタートが一般的で、一定期間操作がない後に関数が呼び出されると、コードの実行に数秒の待ち時間が発生する。

### テスト

開発者は関数コードに対して単体テストを実行できるが、フロントエンドとバックエンドのコンポーネントがどのように相互作用するかを評価する統合テストは、サーバーレス環境では実行が難しい。

### ベンダー・ロックイン

AWS のような大規模なクラウドプロバイダーは、データベース、メッセージングキュー、API など、サーバーレスアプリケーションを実行するために調和して使用できる複数のサービスを提供している。異なるベンダーの要素を混ぜ合わせることは可能だが、単一のプロバイダーのサービスは最もシームレスに統合できるように設計されている。

## 使用例

サーバーレスアーキテクチャは、短時間のタスクの実行や、トラフィックの発生頻度が低かったり予測できなかったりするワークロードの管理に最適である。サーバーレスの主なユースケースは以下の通り

### トリガーベースのタスク

イベントや一連のイベントをトリガーとするユーザーアクティビティは、サーバーレスアーキテクチャの良い候補となる。例えば、ユーザーがウェブサイトにサインアップするとデータベースが変更され、それがウェルカムメールのトリガーになるかもしれない。バックエンドの作業は、サーバーレス関数のチェーンを通じて処理することができる。

### RESTful な API の構築

Amazon API Gateway とサーバーレス機能を活用することで、需要に応じて拡張できる RESTful API を構築できる。

### 非同期処理

サーバーレス関数は、製品情報のレンダリングやアップロード後の動画のトランスコードなど、舞台裏のアプリケーションタスクを、アプリケーションのフローを中断したり、ユーザー向けの待ち時間を増やしたりすることなく処理できる。

### セキュリティチェック

新しいコンテナをスピンアップする際、関数を呼び出してインスタンスの設定ミスや脆弱性をスキャンすることができる。ファンクションは、SSH 認証や二要素認証のよりセキュアなオプションとしても使用できる。

### 継続的インテグレーション（CI）と継続的デリバリー（CD）

サーバーレスアーキテクチャは、CI/CD パイプラインの多くの段階を自動化できる。例えば、コードコミットはビルドを作成する関数をトリガーすることができ、プルリクエストは自動テストをトリガーすることができる。

ほとんどの開発者は段階的にサーバーレスに移行し、アプリケーションの一部を徐々にサーバーレスに移行させ、残りは従来のサーバーに残す。サーバーレスアーキテクチャは簡単に拡張できるため、機会があればいつでも機能を追加できる。

![serverless use case](https://github.com/hiromaily/documents/raw/main/images/serverless-architecture-use-case.avif "severless use case")

## References

- [Datadog: Serverless Architecture Overview](https://www.datadoghq.com/knowledge-center/serverless-architecture/)
- WIP: [サーバーレス技術の今と未来について ServerlessDays Tokyo の PreEvent で話してきました](https://d.nekoruri.jp/entry/2024/09/20/serverlessjp)
