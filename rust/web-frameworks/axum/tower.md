# tower

[Crate tower](https://docs.rs/tower/latest/tower/)

Tower は、堅牢なネットワーキングクライアントおよびサーバーを構築するためのモジュール式で再利用可能なコンポーネントのライブラリー。

Tower は、シンプルなコア抽象化である `Service` trait を提供する。この trait は、リクエストを受け取り、レスポンスまたはエラーを返す非同期関数を表す。 この抽象化は、クライアントとサーバーの両方をモデル化するのに使うことができる。

タイムアウト、レートリミット、ロードバランシングのような一般的なコンポーネントは、`Service`としてモデル化することができ、内部サービスをラップし、内部サービスが呼び出される前または後に追加の動作を適用する。 これにより、プロトコルにとらわれない、コンポーザブルな方法でこれらのコンポーネントを実装することができる。 通常、このようなサービスは`ミドルウェア`と呼ばれる。

追加の抽象化である `Layer` trait は、Services とミドルウェアを構成するために使用される。 `Service` がリクエストタイプからレスポンスタイプへの非同期関数と考えられる場合、 `Layer` はある型の `Service` を受け取り、異なる型の Service を返す関数である。 `ServiceBuilder` 型は、複数の Layer と組み合わせることで、サービスにミドルウェアを追加するために使用される。

## tower のエコシステム

- tower
- tower-service
- tower-layer
- tower-test

Service および Layer 特性は Tower を使用するすべてのライブラリーにとって重要な統合ポイントであるため、可能な限り安定に保たれ、破壊的な変更が加えられることはほとんどない。 そのため、これらは別々のクレート、`tower-service` および `tower-layer` で定義されている。 このクレートはこれらのコア trait の再エクスポート、よく使われるミドルウェアの実装、Service や Layer を扱うためのユーティリティを含んでいる。 最後に、`tower-test` クレートは Tower を使用するプログラムをテストするためのツールを提供する。

## 使用方法

Tower は抽象化レイヤーと、さまざまなミドルウェアの汎用実装を提供する。 つまり、tower クレート単体では、 ネットワーククライアントまたはサーバーの動作する実装を提供しない。 その代わりに、Tower の `Service` trait は、アプリケーションコード、ミドルウェア実装を提供するライブラリー、各種ネットワークプロトコルのサーバーおよび/またはクライアントを実装するライブラリー間の統合ポイントを提供する。

特定のユースケースに応じて、Tower をいくつかの方法で使用することができる

### ネットワークプログラムのアプリケーションロジックの実装

Service trait を使用してアプリケーションの動作をモデル化し、provided by this crate および他のライブラリによって提供されるミドルウェアを使用して、1 つ以上のプロトコル実装によって提供されるクライアントとサーバーに機能を追加する。

### ミドルウェアを実装

ミドルウェアを実装することで、再利用可能な方法でネットワーククライアントとサーバーにカスタム動作を追加する。 これは、汎用ミドルウェア (汎用ミドルウェアの場合は、他の Tower ユーザー向けにライブラリとしてリリースすることを検討すること)、または、複数のクライアントまたはサーバー間で共有する必要があるアプリケーション固有の動作かもしれない。

### ネットワークプロトコルの実装

HTTP などのネットワークプロトコルを実装するライブラリは、`tower-service` に依存して、Service trait をプロトコルとユーザーコードの統合ポイントとして使うことができる。 たとえば、あるプロトコルのクライアントは Service を実装し、ユーザーはこれらのクライアントに任意の Tower ミドルウェアを追加できるようになるかもしれない。 同様に、サーバーはユーザーが提供する Service から作成されるかもしれない。

さらに、ネットワークプロトコルが既存の Tower ミドルウェアによってすでに提供されている機能を必要とする場合、プロトコルの実装は、統合ポイントとしてだけでなく、内部的に Tower ミドルウェアを使用することもある。

## ライブラリーのサポート

多くのサードパーティーライブラリーが Tower と Service trait をサポートしている

- `hyper`
  - 高速で正しい低レベルの HTTP 実装
- `tonic`
  - `hyper`上での`gRPC-over-HTTP/2` の実装。 [example](https://github.com/hyperium/tonic/tree/master/examples/src/tower)
- `warp`
  - 軽量でコンポーザブルな web framework。 [tower での warp の使用方法の詳細](https://docs.rs/warp/0.3.7/warp/fn.service.html)
- `tower-lsp` およびそのフォークである `lspower`
  - Tower ベースの Language Server Protocol の実装

## Getting Started

Tower の初心者で基本から始めたい場合は、[Tower Guides](https://github.com/tower-rs/tower/tree/master/guides)をチェックすること

このクレートで提供されるさまざまなミドルウェア実装には feature フラグが設定されているため、ユーザーは Tower の必要な部分のみをコンパイルすることができる。 デフォルトでは、オプションのミドルウェアはすべて無効になっている。

Tower のすべてのオプションミドルウェアの使用を開始するには、以下を Cargo.toml に追加する

```toml
tower = { version = "0.4", features = ["full"] }
```

また、一部の機能だけを有効にすることもできる。 例えば、retry と timeout ミドルウェアだけを有効にする場合

```toml
tower = { version = "0.4", features = ["retry", "timeout"] }
```

## Tower が提供するすべてのミドルウェア

[tower: Modules](https://docs.rs/tower/latest/tower/#modules)

- balance
  - 複数のサービス間の負荷分散を可能にする
- buffer
  - サービスにバッファされた mpsc チャンネルを提供する
- builder
  - レイヤーとサービスを構成するビルダー型
- discover
  - サービス発見
- filter
  - 述語(predicate)の結果に基づいて内部サービスにリクエストを条件付きでディスパッチする
- hedge
  - 与えられたレイテンシパーセンタイルよりも長い間未解決のリクエストを先取りして再試行する
- layer
  - レイヤーベースのタワー・サービスのコレクション
- limit
  - リクエストを制限するためのタワーミドルウェア
- load
  - サービス負荷測定
- load_shed
  - 内部サービスが準備できていないときにロードを捨てるためのミドルウェア
- make
  - 特定のタイプのレスポンスを生成するサービスの Trait エイリアス
- ready_cache
  - サービスのキャッシュ
- reconnect
  - サービスが失敗したときに再接続する
- retry
  - “failed”リクエストを再試行する
- spawn_ready
  - 基礎となるサービスがレディでないとき、バックグラウンド・タスクでレディにする
- steer
  - このモジュールは Services 間のルーティングリクエストの管理を補助する機能を提供する
- timeout
  - リクエストにタイムアウトを適用するミドルウェア
- util
  - Tower で使用されるさまざまなユーティリティ型と関数
