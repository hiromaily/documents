# CQRS

CQRS stands for Command Query Responsibility Segregation  
コマンドクエリ責務分離

## [CQRSとイベントソーシングの使用法、または「CRUDに何か問題でも？」](https://postd.cc/using-cqrs-with-event-sourcing/)
### DDDの参照系処理で発生する課題
- 基本的には永続化層との入出力はRepositoryを使うことになる
- 一方、参照系の処理、特に一覧画面のような処理では、複数集約の値を組み合わせた結果を画面に返そうとすることが多い
- 1つのUseCase(ApplicationService)で実装しようとすると、3つのRepositoryからそれぞれ値を取得し、戻り値のオブジェクトに詰め替えるような実装にせざるを得ない
- 問題
    - 複数の集約から値を取得して戻り値の型に詰め替える処理が、ループが増えて読みにくいコードになる
    - 画面に返す必要のない値を一度取得するのでパフォーマンスが悪化する
    - 複数集約の条件(where)で絞り込んでのページングができない

- 解決策
    - CQRSの導入

### CQRS
- CQRSとは、「情報の参照に使用するモデルと更新に使用するモデルに異なるものを使用する」というアーキテクチャ
- 更新系のオブジェクトと参照系のオブジェクトを分けるということ

- 更新系モデル -> DDDのEntity、ValueObjectなど -> Repositoryを使用
- 参照系モデル -> 特定のユースケースに特化した値の型。SQLの結果1レコードを1つの型にするなど (DTOといった命名をする) -> 専用のオブジェクト(QueryServiceといった命名をする)

- QueryServiceの実装クラス内では(今回の事例では)複数のテーブルをJoinして一発で取得するクエリを書き、シンプルに結果をDTOに詰め替える

#### メリット
- 複数集約にまたがるデータを取得する際のコードがシンプルになり、メンテナンス性が高まる
- クエリパフォーマンスが上がる、チューニングしやすくなる
- 複数集約の条件(where)で絞り込んでのページングができるようになる

#### デメリット
- オブジェクトの属性が参照されている場所が追いにくくなる
- 元はGetterの参照を追えば確実だったが、別の手段を考える必要が生まれる
- アーキテクチャ自体が複雑になり、解説が必要になる

### CQRS実装時の注意事項
- CQRSは部分的な導入が可能
- 参照用モデルと更新用モデルを完全に分ける必要はない
- なぜQueryServiceの定義がUseCase層なのか
    - QuerySerivceの戻り値がユースケースに依存したものであるから
    - 「ルール・制約」をモデリング表現するドメイン層の責務には含めるべきではない
    - これらの戻り値の型は完全に一致しない限りは使い回すべきではない
    - インフラ層のパフォーマンスチューニングも、特定のユースケースに特化して実装するべき

### よくある誤解
#### データソースを分ける必要があるのか？
- 「CQRS = データソース分離」ではない
- 想定される課題は、参照系のパフォーマンス問題
- 一般に、参照系のリクエスト数は更新系のリクエスト数より圧倒的に多い
- 参照系のパフォーマンスを上げたい時、更新系とはデータソースを分離することで、参照系のインスタンスだけスケールアウトするなどのパフォーマンスチューニングが可能になる
- しかし、データソース分離が解決する課題はモデルの分離とは別のもの

#### イベントソーシングとの関係
- 「CQRS = イベントソーシング」ではない
- 「CQRSとイベントソーシングは相性が良い」というだけ
