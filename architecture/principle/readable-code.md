# リーダブルコード ~より良いコードを書くためのシンプルで実践的なテクニック~

- 「読みやすい」コードを書くのに「面白い」ことをする必要はない
  - いい名前をつける
  - 適切なコメントを書く
  - 意味のある単位に分割する
  - キレイに整形する
- 「読みやすい」コードを書くは、「理解しやすい」コードを書くことであり、その結果として「優れた」コードにつながる
- 優れたコードは見た瞬間に何をしているかが伝わってくる
- コードは理解しやすくなければいけない

## 1 章 理解しやすいコード

- コードは理解しやすくなければいけない
- コードは他の人が最短時間で理解できるように書かなければいけない
- コードは短いほうがいいが、「理解するまでにかかる時間」を短くするほうが大切

## 1 部 表面上の改善

- コードに適切な名前をつければ、優れたコメントを書けば、空白の使い方をキレイにすれば、コードはもっと読みやすくなる

## 2 章 名前に情報を詰め込む

- 名前は短いコメントだと思えばいい
- 明確な単語を選ぶ
  - send, deliver, dispatch, announce, distribute, route
  - find, search, extract, locate, recover
  - start, launch, create, begin, open
  - make, create, set up, build, generate, compose, add, new
- 汎用的な名前を避ける
  - tmp や retval などの汎用的な名前を避ける
  - 変数の値を表すような名前を使う
- 抽象的な名前よりも具体的な名前を使う
- 接尾辞や接頭辞を使って情報を追加する
  - 変数の意味を間違えてしまったときにバグになりそうなところにだけ使うことが大切
  - ハンガリアン記法: すべての変数名の接頭辞に「型」をつける
- 名前の長さを決める
  - スコープが小さければ短い名前でもいい
  - プロジェクト固有の省略形はダメ。新しいメンバーが理解できないようではダメ。
  - 不要な単語は省く ConvertToString => ToString
- 名前のフォーマットで情報を伝える

## 3 章 誤解されない名前

- 名前が「他の意味と間違えられることはないだろうか？」と何度も自問自答する
- filter()はわかりにくい。「選択する」なら`select()`、「除外する」なら`exclude()`
- 限界値を含めるときは`min`と`max`を使う
- 範囲を指定するときは`first`と`last`を使う
- 包含/排他的範囲には`begin`と`end`を使う。`end`は最後を含めない。
- ブール値の変数名には、頭に`is, has, can, should`などをつけてわかりやすくすることが多い
- 名前を否定形にするのは避けたほうがいい

## 4 章 美しさ

- 3 つの原則
  - 読み手が慣れているパターンと一貫性のあるレイアウトを使う
  - 似ているコードは似ているように見せる
  - 関連するコードをまとめてブロックにする
- 見た目が美しいコードのほうが使いやすいのは明らか
- コードを段落に分割する
- 一貫性のあるスタイルは「正しい」スタイルよりも大切

## 5 章 コメントすべきことを知る

- コメントの目的は、書き手の意図を読み手に知らせること
- コードからすぐにわかることをコメントに書かない
- ひどい名前はコメントをつけずに名前を変える
- 通常は補助的なコメントが必要になることはない。
  - 優れたコード > ひどいコード + 優れたコメント
- コメントにはコードに対する大切な考えを記録しなければいけない
- コードの欠陥にコメントをつける
  - TODO: あとで手を付ける
  - FIXME: 既知の不具合があるコード
  - HACK: あまりキレイじゃない解決策
- 定数にコメントをつける
  - 定数を定義するときには、その定数が何をするのか、なぜその値を持っているのかという「背景」が存在する
- 読み手の立場になって考える
  - 質問されそうなことを想像する
  - はまりそうな罠を告知する
  - 全体像のコメント
  - 要約コメント

## 6 章 コメントは正確で簡潔に

- コメントは領域に対する情報の比率が高くなければいけない
- コメントを簡潔にしておく
- あいまいな代名詞を避ける
- 関数の動作を正確に記述する
- コードの意図を書く

## 2 部 ループとロジックの単純化

## 7 章 制御フローを読みやすくする

- 条件やループなどの制御フローはできるだけ「自然」にする。コードの読み手が立ち止まったり読み返したりしないように書く
- 条件式の引数の並び順
  - `if (length >= 10)`のほうが`if (10 <= length)`より見やすい
  - 左側：調査対象の式で変化する。右側：比較対象の式で、あまり変化しない
- if/else ブロックの並び順
  - 条件は否定形よりも肯定形を使う。`if (!debug)`より`if (debug)`を使う
  - 単純な条件を先に書く
  - 関心を引く条件や目立つ条件を先に書く
  - これらは、状況によっては何基準は変わってくる
- 三項演算子
  - 行数を短くするよりも、他の人が理解するのにかかる時間を短くする
  - 基本的に`if/else`を使う。三項演算子はそれによって簡潔になるときだけ使う
- do/while ループを避ける
  - do-statement はエラーや混乱の原因になることが多い
- 関数から早く返す
  - 関数の出口を 1 つにしちあというのは、何らかのクリーンアップコードを確実に実行したい場合
  - 言語ごとにクリーンアップコードのイディオムがある。(golang なら defer)
- ネストを浅くする
  - 早めに返してネストを削除する
- 実行の流れを追えるか？
  - プログラミング言語やライブラリにはコードをバックグラウンドで実行する構成要素がある。こうした構成要素を使っていると、コードを追うのが難しくなる。
    - スレッド
    - シグナル/割り込みハンドラ
    - 例外
    - 関数ポインタと無名関数
    - 仮想メソッド
  - これらは、コード全体に占める割合を大きくしないことが大切

## 8 章 巨大な式を分割する

- 巨大な式は飲み込みやすい大きさに分割する
  - 説明変数
    - 巨大な式を分割できる
    - 簡潔な名前で式を説明することで、コードを文書化できる
    - コードの主要な「概念」を読み手が認識しやすくなる
  - 要約変数
  - ド・モルガンの法則を使う
  - 「頭がいい」コードに気をつける。あとで他の人がコードを読むときにわかりにくくなる
- 巨大な文を分割する

## 9 章 変数と読みやすさ

- 変数が多いと変数を追跡するのが難しくなる
- 変数のスコープが大きいとスコープを把握する時間が長くなる
- 変数が頻繁に変更されると現在の値を把握するのが難しくなる

- 変数を削除する
  - 役に立たない一時変数
  - 中間結果を削除する
  - 制御フロー変数を削除する
- 変数のスコープを縮める
  - グローバル変数は避ける
  - 変数のことが見えるコード行数をできるだけ減らす => 一度に考えなければいけない変数を減らす
  - メンバ変数というのは、クラスのなかでミニグローバルのようなもので、これはできるだけ減らしたほうがいい
  - 大きなクラスを小さなクラスに分割すること。ただし、分割後のクラスが独立していることが条件で、クラス相互にメンバを参照し合うようでは意味がない。
  - 定義の位置を下げる
    - 変数の定義は変数を使う直前に移動すればいい
- 変数は一度だけ書き込む
  - 永続的に変更されない変数は扱いやすく安全である

## 3 部 コードの再編成

## 10 章 無関係の下位問題を抽出する

- 無関係の下位問題を解決しているコードが相当量あれば、それらを抽出して別の関数にする
- これにより関心が分離され、高レベルの目標に集中できるようになる
- プロジェクト固有のコードからユーティリティ、汎用コードとしての抽出
- トップダウンプログラミングとは、先に高レベルのモジュールや関数を設計してから、それらをサポートする低レベルの関数を実装していく方式
- ボトムアッププログラミングとは、先にすべての下位問題を解決してから、それらを利用する高レベルのコンポーネントを実装していく方式
- 小さな関数を作りすぎると、逆に読みにくくなってしまう

## 11 章 一度に１つのことを

- 一度に複数のことをするコードは理解しにくい
- コードは 1 つずつタスクを行うようにしなければならない
- 関数は一度に 1 つのことを行うべき
- 一度に 1 つのタスクをするために
  - コードが行っているタスクをすべて列挙する
  - タスクをできるだけ異なる関数に分割する

## 12 章 コードに思いを込める

- 誰かに複雑な考えを伝えるときには、細かいことまで話しすぎると相手を混乱させてしまう。自分よりも知識が少ない人が理解できるような「簡単な言葉」で説明する能力が大切
- ロジックを明確に説明する
- ライブラリを知る

## 13 章 短いコードを書く

- コードを小さく保つ
  - 汎用的なユーティリティコードを作って、重複コードを削除する
  - 未使用のコードや無用な機能を削除する
  - プロジェクトをサブプロジェクトに分割する
  - コードの重量を意識する。軽量で機敏にしておく
- 身近なライブラリに親しむ

## 4 部 選抜テーマ

## 14 章 テストと読みやすさ

- テストを読みやすくて保守しやすいものにする
  - 他のプログラマが安心してテストの追加や変更ができるように、テストコードを読みやすくする
  - もし、テストコードが大きくて恐ろしいものだったら
    - 本物のコードを修正するのを恐れる
    - 新しいコードを書いたときにテストを追加しなくなる
- テストを読みやすくする
  - 大切ではない詳細はユーザから隠し、大切な詳細は目立つようにする
- エラーメッセージを読みやすくする
- テストの機能に名前をつける
- テストに優しい開発
  - テストしやすいコードには、明確なインターフェースがあり、状態やセットアップが必要ない。検査するデータが隠されていない。
  - テストを書くつもりでコードを書くと、テストしやすいようにコードを設計するようになる [重要]
- テスト駆動開発
  - TDD は本物をコードを書く前にテストを書くというプログラミング手法で、コードを書いてからテストを書くよりもコードの品質が飛躍的に向上すると言われている。
  - プログラムをクラスやメソッドに分割するというのは、疎結合にしたほうがテストしやすいから
  - 外部コンポーネント(初期化に必要なグローバル変数や、読み込みが必要なライブラリや設定ファイルなど)が多いと、それだけテストを書くのが面倒になる
  - テスト容易性が低いコードの特性
    - グローバル変数を使っている
    - 多くの外部コンポーネントに依存している
    - コードが非決定的な動作をする
  - テスト容易性が高いコードの特性
    - クラスが小さい。あるいは内部状態を持たない
    - クラスや関数が 1 つのことをしている
    - クラスは他のクラスにあまり依存していない。高度に疎結合化されている
    - 関数は単純でインターフェースが明確
- テストのやりすぎ
  - テストのために本物のコードの読みやすさを犠牲にしてしまう
  - テストのカバレッジを 100%にしないと気がすまない
  - テストがプロダクト開発の邪魔になる
