# ドメイン駆動設計

- [CQRS](https://github.com/hiromaily/documents/blob/main/domain-driven-design/cqrs.md)

## [ドメイン駆動設計とは何なのか？ ユーザーの業務知識をコードで表現する開発手法について](https://codezine.jp/article/detail/11968)

- ドメイン駆動設計: ユーザーが従事する業務に合わせてソフトウェアを開発する手法
- ユーザーファーストの考え方を実現するための開発手法
- ソフトウェアの利用者を取り巻く世界について、重要な知識が何であるのか知る必要がある
- ソフトウェアの利用者を取り巻く世界と実装を結びつけることを目的とする
- ユーザーの知識がコードに埋め込まれ、ソフトウェアとなる
- ドメインは「領域」の意味をもった言葉で、ソフトウェア開発におけるドメインは、「プログラムを適用する対象となる領域」を指す
- 重要なのはドメインが何かではなく、ドメインに含まれるものが何か
- ドメイン駆動設計は、ドメインの知識に焦点をあてた設計手法
- モデルとは現実の事象あるいは概念を抽象化した概念
- たとえば物流システムにおいて、トラックは「荷運びできる」ことを表現すればそれで十分で、「エンジンキーを回すとエンジンがかかる」といったことまで表現する必要はない、つまり抽象化だけで十分
  - **こういった事象、あるいは概念を抽象化する作業がモデリングと呼ばれる**
- ドメイン駆動設計では、ドメインの概念をモデリングして得られたモデルをドメインモデルと呼ぶ
- **ドメインモデルはあくまでも概念を抽象化した知識にとどまる**
- ドメインモデルは何かしらの媒体で表現されることで、問題解決の力を得る
- ドメインモデルをソフトウェアで動作するモジュールとして表現したものがドメインオブジェクト
- ドメインの概念[アイデア] <=> ドメインモデル[抽象] <=> ドメインオブジェクト[実装]
- ドメインで起こった変化はまずドメインモデルに伝えられる
- ドメインの変化はドメインモデルを媒介にして連鎖的にドメインオブジェクトまで伝えられる

## ドメイン駆動設計

- ドメインは「領域」の意味を持った言葉
- ソフトウェア開発におけるドメインは「プログラムを適用する対象となる領域」
- 重要なのはドメインが何かではなく、ドメインに含まれるものが何か
  - e.g.ユーザー管理のドメイン、支払い管理のドメインなど
- ドメインモデルとは事象を抽象化した概念、トラックの機能は「荷運びができる」ことを表現すれば十分
- 事象、概念を抽象化する作業がモデリング
- その結果として得られる結果がモデル
- ドメイン駆動設計では、ドメインの概念をモデリングして得られたモデルをドメインモデルと呼ぶ
- ドメインモデルをソフトウェアで動作するモジュールとして表現したものがドメインオブジェクト
- ドメイン駆動設計のパターン
  - 知識を表現するパターン
    - 値オブジェクト
    - エンティティ
    - ドメインサービス
  - アプリケーションを実現するためのパターン
    - リポジトリ
    - アプリケーションサービス
    - ファクトリ
  - 知識を表現する、より発展的なパターン
    - 集約
    - 仕様

## システム固有の値を表現する「値オブジェクト」

- システム固有の値を表現するために定義されたオブジェクトが値オブジェクト
- 値の性質は
  - 不変である
    - 代入は変数の内容を変更しているのであって値を変更しているのではない
  - 交換が可能である
    - 値オブジェクトの変更は値と同じように代入操作によって交換をすることで表現される
  - 等価性によって比較される
    - 値は値自身ではなく、それを構成する属性によって比較される
    - 属性を取り出して比較するのではなく、値と同じように値オブジェクト同士が比較できるようにするほうが自然
    - 値オブジェクトが比較するためのメソッドを用意する必要がある
- 値オブジェクトはデータを保持するコンテナではなく、ふるまいを持つことができるオブジェクト
- 値オブジェクトを採用するモチベーション
  - モジュール性の観点で、コードは適切な大きさに細分化し、分散して定義すべき
  - 表現力を増す、不正な値を代入させない、誤った代入を防ぐ、ロジックの散財を防ぐ
- 値オブジェクトのコンセプトは「システム固有の値を作ること」

## ライフサイクルのあるオブジェクト「エンティティ」

- 同一性によって識別される
- 属性によって区別されないオブジェクト、例えばユーザー、ユーザー情報が変更されたとしてもユーザー自身が変更されたわけではない
- ユーザーは属性ではなく同一性（identity）により識別される
- エンティティの性質は
  - 可変である
    - エンティティは交換により変更を行わない。エンティティの属性はその振る舞いを通じて変更する
    - すべての属性を必ず可変にする必要はない、可能な限り不変にしておく
  - 同じ属性であっても区別される
    - 同姓同名だからといって同じユーザーではない、区別するためには識別子（Identity）を利用する
  - 同一性により区別される
    - 同一性を判断するために識別子を利用する
- 値オブジェクトであるかエンティティであるかの判断基準は、ライフサイクルが存在し、そこに連続性が存在するかどうか(作成されたり削除されたりするもの)
- ドメインオブジェクトを定義するメリット
  - コードのドキュメント性が高まる
  - ドメインにおける変更をコードに伝えやすくする

## 不自然さを解決する「ドメインサービス」

- ドメインの概念を知識として落とし込み、それをコードで表現しようとしたとき、値オブジェクトやエンティティの振る舞いとして定義すると違和感が生じるものがある。この振る舞いを別のオブジェクトとして定義する、このオブジェクトこそ、ドメインサービス
- ドメイン駆動設計におけるサービス
  - ドメインサービス...ドメインのためのサービス
  - アプリケーションサービス...アプリケーションのためのサービス
- ドメインサービスは値オブジェクトやエンティティと異なり、自身のふるまいを変更するような**インスタンス特有の状態をもたないオブジェクト**
- 重要なのは、定義すべきは、「不自然なふるまい」に限定すること
- 可能な限りドメインサービスを避ける
- ドメインサービスは値オブジェクトやエンティティと組み合わせて利用する
- ドメインオブジェクトがデータストア操作を取り扱うのは望ましくない...抽象化する
- ドメインオブジェクトはドメインモデルを表現することに徹底する

## データにまつわる処理を分離する「リポジトリ」

- リポジトリはデータを永続化し、再構築するといった処理を抽象的に扱うためのオブジェクト
- 各サービスはデータの永続化と再構築を直接行うのではなく、リポジトリを経由して行う
- リポジトリの責務はドメインオブジェクトの永続化や再構築を行うこと
- リポジトリはインターフェースで定義される
- その後、インターフェースの実体となるリポジトリを実装する(ここで Database などに実際にアクセスする)
- 実装したリポジトリはアプリケーションサービスのコントラストに引き渡される
- データベースに依存しないテスト用のリポジトリも実装する

## ユースケースを実現する「アプリケーションサービス」

- ユースケースを実現するオブジェクト
- ユーザー機能を実現するには「ユーザー登録」や「ユーザー情報変更」など
- アプリケーションは利用者の目的に応じたプログラムのこと
- 開発手順
  - アプリケーションサービスが取り扱うドメインオブジェクトを作成する(エンティティ、値オブジェクト、ドメインサービス)
  - リポジトリのインターフェースと実態のオブジェクトを作成
  - それらを組み合わせてアプリケーションサービスを作成
- アプリケーションサービスはあくまでもドメインオブジェクトのタスク調整に徹するべき
- アプリケーションサービスにはドメインのルールは記述されるべきではない
- **凝縮度**はモジュールの責任範囲がどれだけ集中しているか図る尺度
- 凝縮度を高めるとモジュールがひとつの事柄に集中することになり、堅牢性、信頼性、再利用性、可読性の観点から好ましいとされる
- この凝縮度を測る方法に LCOM（Lack of Cohesion in Methods）という計算式がある
- ただし、凝縮度を高くすることが常に正解ではない
- 責務を厳密に分担するとクラスがわかれるがこれは問題ない。ただし、例えばユーザーに関連する処理にどんなものが含まれているか俯瞰的に見れるようにすべき。このまとまりを表現するために利用するのが「パッケージ」
- パッケージはそのままディレクトリ構造に反映される
- アプリケーションサービスもインターフェースとして定義し、test にはモックオブジェクトを利用する
- サービスは自身のふるまいを変化させる目的で状態を保持しない
- アプリケーションサービスはドメインオブジェクトの操作に徹することでユースケースを実現する

## 柔軟性をもたらす依存関係のコントロール

- ソフトウェアを柔軟に保つために必要なことは、特定の技術的要素への依存を避け、変更の主導権を主たる抽象に移すこと
- 重要なことは依存を避けることではなく、コントロールすること
- 依存はあるオブジェクトからあるオブジェクトを参照するだけで発生する
- ソフトウェアが健全に成長するためには開発やテストで気軽にコードを実行できるように仕向けることが重要、特定のデータストアに結びつくとそれは不可能になる
- **依存関係逆転の原則（Dependency Inversion Principle）**
  - A. 上位レベルのモジュールは下位レベルのモジュールに依存してはならない、どちらのモジュールも抽象に依存すべき
  - B. 抽象は、実装の詳細に依存してはならない。実装の詳細が抽象に依存すべき
- プログラムにはレベルと呼ばれる概念がある。レベルは入出力からの距離を示す。低レベルといえば機会に近い具体的な処理を指し、高レベルといえば人間に近い抽象的な処理を指す。
- 主体となるべきは高レベルなモジュール、すなわち抽象。高レベルなモジュールは低レベルのモジュールを利用するクライアント。主導権はクライアントにある。インターフェースを宣言し、低レベルのモジュールはそのインターフェースに合わせて実装を行う。
- 依存関係をコントロールするパターンとして、Service Locator パターンと、IoC Container パターンがある
- A. Service Locator パターン
  - ServiceLocator と呼ばれるオブジェクトに依存解決先となるオブジェクトを事前に登録しておき、インスタンスが必要となる各所で ServiceLocator を経由してインスタンスを取得するパターン
  - ServiceLocator に登録されるインスタンスの設計は production, test と環境に応じて一括で管理すると便利。スタートアップスクリプトで、環境ごとにインスタンス設定を切り替えを行えるようにする
  - 一方で、Service Locator パターンはアンチパターンであるともいわれている
    - 依存関係が外部から見えづらくなる
    - テストの維持が難しくなる
- B. **IoC Container パターン**
  - DI Container...Dependency Injection パターン
  - コンストラクタで依存するオブジェクトを注入する

## 複雑な生成処理を行う「ファクトリ」

- ファクトリは作る知識に特化したオブジェクト
- モデルを表現するオブジェクトに無理やり実装するよりも、オブジェクトの生成それ自体を独立したオブジェクトとするほうがコードの意図を明確にすることに繋がる
- 複雑なオブジェクトの生成処理をオブジェクトとして定義、この生成を責務とするオブジェクトのことを「ファクトリ」
- ファクトリのインターフェースを用意
- ファクトリの存在に気づかせるための仕掛けとして、同じパッケージに同居させファイル名でわかるようにする
- 利用するモチベーション
  - ポリモーフィズムの恩恵を与えるためにファクトリを利用する
  - 生成方法が複雑なインスタンスを構築する処理をまとめるためにファクトリを利用する
  - 本来であれば初期化はコンストラクタの役目だが、コンストラクタが単純でなくなるとき

## ドメインのルールを守る「集約」

- データを変更するための単位として扱われるオブジェクトの集まりを集約
- 集約は不変条件を維持する単位として切り出され、オブジェクトの操作に秩序をもたらす
- 外部から内部のオブジェクトに対して直接操作するのではなく、それを保持するオブジェクト(親オブジェクト)に依頼する形を取る (デメテルの法則)
  - ~~circle.Member.Add(member)~~
  - circle.AddMember(member)
- 集約の大きさはなるべく小さく保つべき
- 複数の集約をまたがるような処理を取り扱いときに利用できるのが**結果整合性**

## 複雑な条件を表現する「仕様」

- 仕様はオブジェクトの評価を行うオブジェクト

## アーキテクチャ

- ドメイン駆動設計はドメインと向き合いながらモデルをコードに落とし込むことで、ドメインとコードを結びつけるプラクティス
- ドメイン駆動設計は特定のアーキテクチャを前提とすることはない
- アーキテクチャは知識を記述すべき箇所を示す方針
- アンチパターン: 利口な UI
  - 本来であればドメインオブジェクトに記載されるべき重要なルールや振る舞いが UI に記載されてしまっている状態を揶揄する
  - これはドメインを分離することが敵わなかったアプリケーションに多く見られる
  - UI は入力と表示がその責務で、ビジネスに関わるようなロジックは可能な限り記述されるべきではない
- アーキテクチャは方針。何がどこに記述されるべきかといった疑問に対する回答を明確にし、ロジックが無秩序に点在することを防ぐ
- ドメイン駆動設計がアーキテクチャに求めることは、ドメインオブジェクトが渦巻くレイヤーを隔離して、ソフトウェア特有の事情からドメインオブジェクトを防衛すること
- 以下はドメイン駆動設計と同時に語られることの多いアーキテクチャ
  - レイヤードアーキテクチャ
  - ヘキサゴナルアーキテクチャ
  - クリーンアーキテクチャ
- ドメイン駆動設計にとってはドメインが隔離されることのみが重要であり、必ずしもこのいずれかのアーキテクチャに従わなければいけないわけではない
- 重要なのはドメインの本質に集中する環境を用意すること

### レイヤードアーキテクチャ

- いくつかの層が積み重なる形で表現される
- レイヤードアーキテクチャが構成する 4 つの層
  - プレゼンテーション層（ユーザーインターフェース層）
  - アプリケーション層
  - ドメイン層
  - インフラストラクチャ層
- ドメイン層
  - もっとも重要な層
  - ドメインオブジェクトの隔離を促し、他の層へ流出しないようにする
- アプリケーション層
  - ドメイン層のオブジェクトを取りまとめる層
  - ユースケースを実現するための進行役になる
- プレゼンテーション層
  - UI とアプリケーションを結びつける
  - コントローラー
- インフラストラクチャ層
  - 他の層を支える技術的基盤へのアクセスを提供する層
- [ユーザーインターフェース]-[アプリケーション]-[ドメイン]-[インフラストラクチャ]

### ヘキサゴナルアーキテクチャ

- コンセプトはアプリケーションとそれ以外のインターフェースや保存媒体は付け外しができるようにするというもの
- つまりインターフェースを利用した依存関係の整理が重要
- レイヤードアーキテクチャは層分けを言及しているに過ぎないので、インターフェースを取り扱うかどうかは任意
- インターフェースを利用して依存関係の逆転を達成することは当たり前なので、両者の垣根はほとんどない

### クリーンアーキテクチャ

- 4 つの同心円が特徴的な図によって説明される
- 中心の Entities はビジネスルールをカプセル化したオブジェクトないし、データ構造と関数のセットを指す（ドメインオブジェクトに近い）
- ユーザーインターフェースやデータストアなどの詳細を端に追いやり、依存の方向を内側に向けることで、詳細が抽象に依存するという依存関係逆転の法則を達成する
- ヘキサゴナルアーキテクチャとクリーンアーキテクチャの大きな違いはその実装の仕方が詳しく言及されているかどうか
- 最も重要なコンセプトはビジネスルールをカプセル化したモジュールの中心に捉え、依存の方向を絶対的に制御すること
