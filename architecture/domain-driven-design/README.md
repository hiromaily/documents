# ドメイン駆動設計

アーキテクチャではなく開発手法
ドメイン駆動設計においてはドメインが隔離されることのみが重要

## [ドメイン駆動設計とは何なのか？ ユーザーの業務知識をコードで表現する開発手法について](https://codezine.jp/article/detail/11968)

- ドメイン駆動設計: ユーザーが従事する業務に合わせてソフトウェアを開発する手法
- ユーザーファーストの考え方を実現するための開発手法
- ソフトウェアの利用者を取り巻く世界について、重要な知識が何であるのか知る必要がある
- ソフトウェアの利用者を取り巻く世界と実装を結びつけることを目的とする
- ユーザーの知識がコードに埋め込まれ、ソフトウェアとなる
- ドメインは「領域」の意味をもった言葉で、ソフトウェア開発におけるドメインは、「プログラムを適用する対象となる領域」を指す
- 重要なのはドメインが何かではなく、ドメインに含まれるものが何か
- ドメイン駆動設計は、ドメインの知識に焦点をあてた設計手法
- モデルとは現実の事象あるいは概念を抽象化した概念
- たとえば物流システムにおいて、トラックは「荷運びできる」ことを表現すればそれで十分で、「エンジンキーを回すとエンジンがかかる」といったことまで表現する必要はない、つまり抽象化だけで十分
  - **こういった事象、あるいは概念を抽象化する作業がモデリングと呼ばれる**
- ドメイン駆動設計では、ドメインの概念をモデリングして得られたモデルをドメインモデルと呼ぶ
- **ドメインモデルはあくまでも概念を抽象化した知識にとどまる**
- ドメインモデルは何かしらの媒体で表現されることで、問題解決の力を得る
- ドメインモデルをソフトウェアで動作するモジュールとして表現したものがドメインオブジェクト
- ドメインの概念[アイデア] <=> ドメインモデル[抽象] <=> ドメインオブジェクト[実装]
- ドメインで起こった変化はまずドメインモデルに伝えられる
- ドメインの変化はドメインモデルを媒介にして連鎖的にドメインオブジェクトまで伝えられる

## ドメイン駆動設計入門まとめ

### 1. ドメイン駆動設計とは

- ドメインは「領域」の意味を持った言葉
- ソフトウェア開発におけるドメインは「プログラムを適用する対象となる領域」
- 重要なのはドメインが何かではなく、ドメインに含まれるものが何か
  - e.g.ユーザー管理のドメイン、支払い管理のドメインなど
- ドメインモデルとは事象を抽象化した概念、トラックの機能は「荷運びができる」ことを表現すれば十分
- 事象、概念を抽象化する作業がモデリング
- その結果として得られる結果がモデル
- ドメイン駆動設計では、ドメインの概念をモデリングして得られたモデルをドメインモデルと呼ぶ
- ドメインモデルをソフトウェアで動作するモジュールとして表現したものがドメインオブジェクト
- ドメイン駆動設計のパターン
  - 知識を表現するパターン
    - 値オブジェクト
    - エンティティ
    - ドメインサービス
  - アプリケーションを実現するためのパターン
    - リポジトリ
    - アプリケーションサービス
    - ファクトリ
  - 知識を表現する、より発展的なパターン
    - 集約
    - 仕様

### 2. システム固有の値を表現する「値オブジェクト」

- システム固有の値を表現するために定義されたオブジェクトが値オブジェクト
- 値の性質は
  - 不変である
    - 代入は変数の内容を変更しているのであって値を変更しているのではない
  - 交換が可能である
    - 値オブジェクトの変更は値と同じように代入操作によって交換をすることで表現される
  - 等価性によって比較される
    - 値は値自身ではなく、それを構成する属性によって比較される
    - 属性を取り出して比較するのではなく、値と同じように値オブジェクト同士が比較できるようにするほうが自然
    - 値オブジェクトが比較するためのメソッドを用意する必要がある
- 値オブジェクトはデータを保持するコンテナではなく、ふるまいを持つことができるオブジェクト
- 値オブジェクトを採用するモチベーション
  - モジュール性の観点で、コードは適切な大きさに細分化し、分散して定義すべき
  - 表現力を増す、不正な値を代入させない、誤った代入を防ぐ、ロジックの散財を防ぐ
- 値オブジェクトのコンセプトは「システム固有の値を作ること」

### 3. ライフサイクルのあるオブジェクト「エンティティ」

- 同一性によって識別される (Identity)
- 属性によって区別されないオブジェクト、例えばユーザー、ユーザー情報が変更されたとしてもユーザー自身が変更されたわけではない
- ユーザーは属性ではなく同一性（identity）により識別される
- エンティティの性質は
  - 可変である
    - エンティティは交換により変更を行わない。エンティティの属性はその振る舞いを通じて変更する
    - すべての属性を必ず可変にする必要はない、可能な限り不変にしておく
  - 同じ属性であっても区別される
    - 同姓同名だからといって同じユーザーではない、区別するためには識別子（Identity）を利用する
  - 同一性により区別される
    - 同一性を判断するために識別子を利用する
- 値オブジェクトであるかエンティティであるかの判断基準は、ライフサイクルが存在し、そこに連続性が存在するかどうか(作成されたり削除されたりするもの)
- ドメインオブジェクトを定義するメリット
  - コードのドキュメント性が高まる
  - ドメインにおける変更をコードに伝えやすくする

### 4. 不自然さを解決する「ドメインサービス」

- ドメインの概念を知識として落とし込み、それをコードで表現しようとしたとき、値オブジェクトやエンティティの振る舞いとして定義すると違和感が生じるものがある。この振る舞いを別のオブジェクトとして定義する、このオブジェクトこそ、ドメインサービス
- ドメイン駆動設計におけるサービス
  - ドメインサービス...ドメインのためのサービス
  - アプリケーションサービス...アプリケーションのためのサービス
- ドメインサービスは値オブジェクトやエンティティと異なり、自身のふるまいを変更するような**インスタンス特有の状態をもたないオブジェクト**
- 重要なのは、定義すべきは、「不自然なふるまい」に限定すること
- 可能な限りドメインサービスを避ける
- ドメインサービスは値オブジェクトやエンティティと組み合わせて利用する
- ドメインオブジェクトがデータストア操作を取り扱うのは望ましくない...抽象化する
- ドメインオブジェクトはドメインモデルを表現することに徹底する

### 5. データにまつわる処理を分離する「リポジトリ」

- リポジトリはデータを永続化し、再構築するといった処理を抽象的に扱うためのオブジェクト
- 各サービスはデータの永続化と再構築を直接行うのではなく、リポジトリを経由して行う
- リポジトリの責務はドメインオブジェクトの永続化や再構築を行うこと
- リポジトリはインターフェースで定義される
- その後、インターフェースの実体となるリポジトリを実装する(ここで Database などに実際にアクセスする)
- 実装したリポジトリはアプリケーションサービスのコントラストに引き渡される
- データベースに依存しないテスト用のリポジトリも実装する

### 6. ユースケースを実現する「アプリケーションサービス」

- ユースケースを実現するオブジェクト
- ユーザー機能を実現するには「ユーザー登録」や「ユーザー情報変更」など
- アプリケーションは利用者の目的に応じたプログラムのこと
- 開発手順
  - アプリケーションサービスが取り扱うドメインオブジェクトを作成する(エンティティ、値オブジェクト、ドメインサービス)
  - リポジトリのインターフェースと実態のオブジェクトを作成
  - それらを組み合わせてアプリケーションサービスを作成
- アプリケーションサービスはあくまでもドメインオブジェクトのタスク調整に徹するべき
- アプリケーションサービスにはドメインのルールは記述されるべきではない
- **凝縮度**はモジュールの責任範囲がどれだけ集中しているか図る尺度
- 凝縮度を高めるとモジュールがひとつの事柄に集中することになり、堅牢性、信頼性、再利用性、可読性の観点から好ましいとされる
- この凝縮度を測る方法に LCOM（Lack of Cohesion in Methods）という計算式がある
- ただし、凝縮度を高くすることが常に正解ではない
- 責務を厳密に分担するとクラスがわかれるがこれは問題ない。ただし、例えばユーザーに関連する処理にどんなものが含まれているか俯瞰的に見れるようにすべき。このまとまりを表現するために利用するのが「パッケージ」
- パッケージはそのままディレクトリ構造に反映される
- アプリケーションサービスもインターフェースとして定義し、test にはモックオブジェクトを利用する
- サービスは自身のふるまいを変化させる目的で状態を保持しない
- アプリケーションサービスはドメインオブジェクトの操作に徹することでユースケースを実現する

### 7. 柔軟性をもたらす依存関係のコントロール

- ソフトウェアを柔軟に保つために必要なことは、特定の技術的要素への依存を避け、変更の主導権を主たる抽象に移すこと
- 重要なことは依存を避けることではなく、コントロールすること
- 依存はあるオブジェクトからあるオブジェクトを参照するだけで発生する
- ソフトウェアが健全に成長するためには開発やテストで気軽にコードを実行できるように仕向けることが重要、特定のデータストアに結びつくとそれは不可能になる
- **依存関係逆転の原則（Dependency Inversion Principle）**
  - A. 上位レベルのモジュールは下位レベルのモジュールに依存してはならない、どちらのモジュールも抽象に依存すべき
  - B. 抽象は、実装の詳細に依存してはならない。実装の詳細が抽象に依存すべき
- プログラムにはレベルと呼ばれる概念がある。レベルは入出力からの距離を示す。低レベルといえば機会に近い具体的な処理を指し、高レベルといえば人間に近い抽象的な処理を指す。
- 主体となるべきは高レベルなモジュール、すなわち抽象。高レベルなモジュールは低レベルのモジュールを利用するクライアント。主導権はクライアントにある。インターフェースを宣言し、低レベルのモジュールはそのインターフェースに合わせて実装を行う。
- 依存関係をコントロールするパターンとして、Service Locator パターンと、IoC Container パターンがある
- A. Service Locator パターン
  - ServiceLocator と呼ばれるオブジェクトに依存解決先となるオブジェクトを事前に登録しておき、インスタンスが必要となる各所で ServiceLocator を経由してインスタンスを取得するパターン
  - ServiceLocator に登録されるインスタンスの設計は production, test と環境に応じて一括で管理すると便利。スタートアップスクリプトで、環境ごとにインスタンス設定を切り替えを行えるようにする
  - 一方で、Service Locator パターンはアンチパターンであるともいわれている
    - 依存関係が外部から見えづらくなる
    - テストの維持が難しくなる
- B. **IoC Container パターン**
  - DI Container...Dependency Injection パターン
  - コンストラクタで依存するオブジェクトを注入する

### 9. 複雑な生成処理を行う「ファクトリ」

- ファクトリは作る知識に特化したオブジェクト
- モデルを表現するオブジェクトに無理やり実装するよりも、オブジェクトの生成それ自体を独立したオブジェクトとするほうがコードの意図を明確にすることに繋がる
- 複雑なオブジェクトの生成処理をオブジェクトとして定義、この生成を責務とするオブジェクトのことを「ファクトリ」
- ファクトリのインターフェースを用意
- ファクトリの存在に気づかせるための仕掛けとして、同じパッケージに同居させファイル名でわかるようにする
- 利用するモチベーション
  - ポリモーフィズムの恩恵を与えるためにファクトリを利用する
  - 生成方法が複雑なインスタンスを構築する処理をまとめるためにファクトリを利用する
  - 本来であれば初期化はコンストラクタの役目だが、コンストラクタが単純でなくなるとき

### 11. アプリケーションを１から組み立てる

- アプリケーションを組み立てるフロー
  - どういった機能が求められているか (必要な機能の整理)
  - その機能を成り立たすためのユースケースを洗い出す
  - そのユースケース実現のためのドメインオブジェクトを準備（知識・ルール)
  - ドメインオブジェクトを用いてユースケースを実現するアプリケーションサービスを実装する

### 12. ドメインのルールを守る「集約」

- データを変更するための単位として扱われるオブジェクトの集まりを集約
- 集約は不変条件を維持する単位として切り出され、オブジェクトの操作に秩序をもたらす
- 外部から内部のオブジェクトに対して直接操作するのではなく、それを保持するオブジェクト(親オブジェクト)に依頼する形を取る (デメテルの法則)
  - ~~circle.Member.Add(member)~~
  - circle.AddMember(member)
- 集約の大きさはなるべく小さく保つべき
- 複数の集約をまたがるような処理を取り扱いときに利用できるのが**結果整合性**

### 13. 複雑な条件を表現する「仕様」

- 仕様はオブジェクトの評価を行うオブジェクト

### 14. アーキテクチャ

- ドメイン駆動設計はドメインと向き合いながらモデルをコードに落とし込むことで、ドメインとコードを結びつけるプラクティス
- ドメイン駆動設計は特定のアーキテクチャを前提とすることはない
- アーキテクチャは知識を記述すべき箇所を示す方針
- アンチパターン: 利口な UI
  - 本来であればドメインオブジェクトに記載されるべき重要なルールや振る舞いが UI に記載されてしまっている状態を揶揄する
  - これはドメインを分離することが敵わなかったアプリケーションに多く見られる
  - UI は入力と表示がその責務で、ビジネスに関わるようなロジックは可能な限り記述されるべきではない
- アーキテクチャは方針。何がどこに記述されるべきかといった疑問に対する回答を明確にし、ロジックが無秩序に点在することを防ぐ
- ドメイン駆動設計がアーキテクチャに求めることは、ドメインオブジェクトが渦巻くレイヤーを隔離して、ソフトウェア特有の事情からドメインオブジェクトを防衛すること
- 以下はドメイン駆動設計と同時に語られることの多いアーキテクチャ
  - レイヤードアーキテクチャ
  - ヘキサゴナルアーキテクチャ
  - クリーンアーキテクチャ
- ドメイン駆動設計にとってはドメインが隔離されることのみが重要であり、必ずしもこのいずれかのアーキテクチャに従わなければいけないわけではない
- 重要なのはドメインの本質に集中する環境を用意すること

#### レイヤードアーキテクチャ

- いくつかの層が積み重なる形で表現される
- レイヤードアーキテクチャが構成する 4 つの層
  - プレゼンテーション層（ユーザーインターフェース層）
  - アプリケーション層
  - ドメイン層
  - インフラストラクチャ層
- ドメイン層
  - もっとも重要な層
  - ドメインオブジェクトの隔離を促し、他の層へ流出しないようにする
- アプリケーション層
  - ドメイン層のオブジェクトを取りまとめる層
  - ユースケースを実現するための進行役になる
- プレゼンテーション層
  - UI とアプリケーションを結びつける
  - コントローラー
- インフラストラクチャ層
  - 他の層を支える技術的基盤へのアクセスを提供する層
- [ユーザーインターフェース]-[アプリケーション]-[ドメイン]-[インフラストラクチャ]

#### ヘキサゴナルアーキテクチャ

- コンセプトはアプリケーションとそれ以外のインターフェースや保存媒体は付け外しができるようにするというもの
- つまりインターフェースを利用した依存関係の整理が重要
- レイヤードアーキテクチャは層分けを言及しているに過ぎないので、インターフェースを取り扱うかどうかは任意
- レイヤードアーキテクチャでもインターフェースを利用して依存関係の逆転を達成することは当たり前なので、両者の垣根はほとんどない

#### クリーンアーキテクチャ

- 4 つの同心円が特徴的な図によって説明される
- 中心の Entities はビジネスルールをカプセル化したオブジェクトないし、データ構造と関数のセットを指す（ドメインオブジェクトに近い）
- ユーザーインターフェースやデータストアなどの詳細を端に追いやり、依存の方向を内側に向けることで、詳細が抽象に依存するという依存関係逆転の法則を達成する
- ヘキサゴナルアーキテクチャとクリーンアーキテクチャの大きな違いはその実装の仕方が詳しく言及されているかどうか
- 最も重要なコンセプトはビジネスルールをカプセル化したモジュールの中心に捉え、依存の方向を絶対的に制御すること

### まとめ

- 実装
  - **値オブジェクト** or **エンティティ** (ユーザーなど、属性によって区別されないオブジェクト)
    - ここはそこまで意識しなくてもいい
  - **ドメインサービス** (値オブジェクトやエンティティで表現できない、振る舞いなどを定義)
    - 可能な限り避ける
    - 例) User 作成などのユースケースなど
    - サービスから抽象に依存することになる
      - DB を持つシステムの場合、後述の repository を属性として保持することが多い
    - XXXService という名前になる
  - **アプリケーションサービス** (ユースケースを表現するオブジェクト)
    - ドメインサービス、リポジトリなどの Interface を属性に持つことになる
    - ドメインオブジェクトの振る舞いを呼び出す役目を持つ
    - ここにドメインのルールが記述されるべきではない
    - XXXApplicationService という名前になる
      - CLI であればコマンドで実行処理?
      - Web であれば Handler の処理?
    - ドメインオブジェクトのタスク調整に徹するべきで、ドメインのルールが記述されるべきではない
    - アプリケーションサービス自体を抽象化し、その上位の Client から制御する
    - MVC であれば、C が ApplicationService の抽象に依存する。つまりビジネスロジックを請け負う。
- 抽象+実装
  - **リポジトリ: repository**
    - データの操作処理を抽象的に扱うもの
      - Interface で定義されるため、IUserRepository といった名前など(Golang の場合は UserRepository でよい)
    - repository において、データストアが RDB なのか NoSQL なのかファイルなのかということは重要ではない
    - 抽象の実体としての実装を示すものも、repository として定義されている
    - Database に依存しない、Test 用の repository(実体)を用意することで、Test が容易に実行できる
    - Update の処理は 1 つあればよく、内部の特定の field のみ更新といった処理は上位レイヤー(ドメインサービスなど)に委ねる
      - そのためには、record 単位の object をドメイン(値オブジェクト or エンティティ)として定義する必要がある
- 依存の向き
  - ApplicationService -> Service -> Repository(Interface) -> Repository(Impl)
- **凝集度**
  - モジュールの責任版にがどれだけ集中しているか測る尺度で、凝集度を高めるとモジュールが一つの事柄に集中することになる
    - 結果、堅牢性・信頼性・再利用性・可読性が向上する
  - 凝集度を高めることが常に政界ではなく、コードを取り巻く環境によってあえて凝集度を下げるということも有り得る点に注意する
  - 同じグループ(例えば User 関連処理)で責務毎にクラス(もしくはファイル)を分けても俯瞰的に閲覧できるべきで、`パッケージ`を使う
    - [Application] - [Users] - UsersXXXService \* n
- 依存のコントロール: ソフトウェアを柔軟に保つ
  - 特定の技術的要素への依存を避け、変更の主導権を主たる抽象に移す
  - Interface と実装があるとき、実装が Interface に依存することになる
  - **依存関係逆転の法則 (Dependency Inversion Principle)**
    - 上位レベルのモジュールは下位レベルのモジュールに依存してはならず、抽象に依存すべき
    - 実装の詳細が抽象に依存すべき
  - 依存関係をコントロールするパターンの１つ、**IoC Container (Inversion of Control)** パターン
    - DI Container (Dependency Injection): 依存の注入
      - コンストラクタで依存するオブジェクトを注入するパターン
      - メソッドで注入すうｒメソッドインジェクションというパターン
    - 依存するオブジェクトのインスタンス化は一箇所で行うべきで、`スタートアップスクリプト`内で行う
- **ファクトリ**
  - 複雑な生成処理を行うために、オブジェクトの生成自体をオブジェクトとして定義する
  - コンストラクタが複雑になる場合には有効だが、コンストラクタの責務は`パラメータを受け取るのみ`にすれば複雑にならない
  - Interface も必要あらば定義する
  - ファクトリの命名は`UserFactory`など
- **アーキテクチャ**は方針。何がどこに記述されるべきかといった疑問に対する回答を明確にし、ロジックが無秩序に点在することを防ぐ
- **ユビキタス言語**
  - ドメインエキスパート、開発者が共に使うプロジェクトにおける共通言語
- **境界づけられたコンテキスト**

## 実践ドメイン駆動設計から学ぶ DDD の実装入門

DDD はソフトウェア開発手法の１つで、顧客と開発者が業務を戦略的に理解し、共通の言葉を使いながらシステムを発展させる手法。チームの共通言語である`ユビキタス言語`を用いて`ドメインモデル`を構築し、それをコードとして実装する。大規模で密結合なシステムにならないように`ドメイン`と`境界づけられたコンテキスト`でシステムを分割し、`コアドメイン`という最重要領域に集中して開発を行う

`戦略的設計`: チームで使うパターンのことで、ビジネスにおける言語に価値を置き、業務に関わる人の考え方をドメインモデルとして表現する  
`戦術的設計`: テクニカルなパターンのことで、アーキテクチャ、DDD 固有のパターンといった技術的内容が含まれる。

`戦略的設計`を実施せず、エンジニアが取り組みやすい`戦術的設計`にだけ注力すると、`軽量DDD`とよばれる事業価値を発揮できない貧弱な DDD になってしまう

### 1. DDD への誘い ~ドメイン駆動設計のメリットと始め方~

- `ドメインエキスパート`とは、担当業務やシステムについて一番詳しい人を指す。そのため、顧客に限らず、プロマネ、SE やプログラマの可能性もある。
- 単純なマスタメンテナンスや 30 程度のユースケースフローでは DDD を導入するコストのほうが高く付く。
  - 将来的に複雑に成長していくことがわかっているシステムにメリットがある
- DDD の 3 原則
  - コアドメインに集中すること
  - ドメインの実践者とソフトウェアの実践者による創造的な共同作業を通じて、モデルを探求すること
  - 明示的な境界づけられたコンテキストの内部でユビキタス言語を語ること

### 2. ドメイン、サブドメイン、境界づけられたコンテキスト ~DDD で取り組む領域~

- 1 つのコアドメインもしくはサブドメインに 1 つの境界づけられたコンテキストが対応している状態が最適だとされている
- 例えば`アカウント`という言葉は、会計システムや営業管理システムで意味が変わってくる
- つまり言葉が 2 つ以上の意味を持たないように`境界づけられたコンテキスト`が存在する

## 軽量 DDD 考察

実際に開発者がドメインエキスパートと協力して、ドメインにおいて有益な概念を作り上げているような環境は稀であり、多くの組織がこの状態に陥っているのではないか？
~~DDD が提唱されたのは 2003 年、まだ web システムも少なく BtoB のシステムがソフトウェア業界の主流の開発物であり、SIer のような業務形態からみた開発手法にも見える。BtoC のサービスにおいては、`戦略的設計`を実施せず、エンジニアが取り組みやすい`戦術的設計`にだけ注力すること、つまり軽量 DDD は理にかなっているようにも思える~~
