# CQRS

コマンドクエリ責務分離: CQRS stands for Command Query Responsibility Segregation
つまり、コマンド・照会の分離原則 (Command Query Segregation)

- 関数は何らかの処理を行うか、何らかの応答を返すかのどちらかを行うべきで、両方を行うべきではない。
- 両方同時に行うと混乱を招く

## [CQRS とイベントソーシングの使用法、または「CRUD に何か問題でも？」](https://postd.cc/using-cqrs-with-event-sourcing/)

### DDD の参照系処理で発生する課題

- 基本的には永続化層との入出力は Repository を使うことになる
- 一方、参照系の処理、特に一覧画面のような処理では、複数集約の値を組み合わせた結果を画面に返そうとすることが多い
- 1 つの UseCase(ApplicationService)で実装しようとすると、3 つの Repository からそれぞれ値を取得し、戻り値のオブジェクトに詰め替えるような実装にせざるを得ない
- 問題

  - 複数の集約から値を取得して戻り値の型に詰め替える処理が、ループが増えて読みにくいコードになる
  - 画面に返す必要のない値を一度取得するのでパフォーマンスが悪化する
  - 複数集約の条件(where)で絞り込んでのページングができない

- 解決策
  - CQRS の導入

### CQRSの適用例

- CQRS とは、「情報の参照に使用するモデルと更新に使用するモデルに異なるものを使用する」というアーキテクチャ
- 更新系のオブジェクトと参照系のオブジェクトを分けるということ

- 更新系モデル -> DDD の Entity、ValueObject など -> Repository を使用
- 参照系モデル -> 特定のユースケースに特化した値の型。SQL の結果 1 レコードを 1 つの型にするなど (DTO といった命名をする) -> 専用のオブジェクト(QueryService といった命名をする)

- QueryService の実装クラス内では(今回の事例では)複数のテーブルを Join して一発で取得するクエリを書き、シンプルに結果を DTO に詰め替える

#### メリット

- 複数集約にまたがるデータを取得する際のコードがシンプルになり、メンテナンス性が高まる
- クエリパフォーマンスが上がる、チューニングしやすくなる
- 複数集約の条件(where)で絞り込んでのページングができるようになる

#### デメリット

- オブジェクトの属性が参照されている場所が追いにくくなる
- 元は Getter の参照を追えば確実だったが、別の手段を考える必要が生まれる
- アーキテクチャ自体が複雑になり、解説が必要になる

### CQRS 実装時の注意事項

- CQRS は部分的な導入が可能
- 参照用モデルと更新用モデルを完全に分ける必要はない
- なぜ QueryService の定義が UseCase 層なのか
  - QuerySerivce の戻り値がユースケースに依存したものであるから
  - 「ルール・制約」をモデリング表現するドメイン層の責務には含めるべきではない
  - これらの戻り値の型は完全に一致しない限りは使い回すべきではない
  - インフラ層のパフォーマンスチューニングも、特定のユースケースに特化して実装するべき

### よくある誤解

#### データソースを分ける必要があるのか？

- 「CQRS = データソース分離」ではない
- 想定される課題は、参照系のパフォーマンス問題
- 一般に、参照系のリクエスト数は更新系のリクエスト数より圧倒的に多い
- 参照系のパフォーマンスを上げたい時、更新系とはデータソースを分離することで、参照系のインスタンスだけスケールアウトするなどのパフォーマンスチューニングが可能になる
- しかし、データソース分離が解決する課題はモデルの分離とは別のもの

#### イベントソーシングとの関係

- 「CQRS = イベントソーシング」ではない
- 「CQRS とイベントソーシングは相性が良い」というだけ
