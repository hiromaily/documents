# Architecture

ソフトウェアアーキテクチャのルールとは、プログラムの構成要素をどのように組み立てるかのルール  
優れたアーキテクチャーは、ユースケースを強調し、周辺の関心ごとからユースケースを切り離す  
テスト可能なアーキテクチャーにおいて、テストするために Database の起動も必要ないし、Web サーバーの起動も必要ない  
フレームワーク非依存であるべき  
(CleanArchitecture からの抜粋)

## アーキテクチャの変遷

- [レイヤードアーキテクチャ](./layered-architecture.md)
- [ヘキサゴナルアーキテクチャ](./hexagonal-architecture.md)
- オニオンアーキテクチャ
- [Clean Architecture](./clean-architecture.md)

## アーキテクチャ適用のメリット

- 実装のための指針となるため、コードに規則性が生まれ、可読性が向上する
  - 逆に言えばアーキテクチャの適用抜きに長期的なシステムメンテナンスは不可能
- コードレビュー時に無益な論争が避けられる

## [12 のソフトウェア・アーキテクチャの落とし穴とその避け方](https://www.infoq.com/jp/articles/avoid-architecture-pitfalls/)

- アーキテクチャを構築していない人は、アーキテクチャに関する決定を下すべきではない。アーキテクチャを形成する重要な技術的トレードオフを行うには、アーキテクチャがどのように構築されるかについての知識が不可欠である。
- 品質属性要件（Quality Assurance Requirements: QAR）はアーキテクチャ設計の原動力となる。これらの要件を無視したり、不十分な定義にしたりすることは、失敗のもとである。
- アーキテクチャの決定をベンダーに委ねてはならない。ベンダーはあなたのコンテキストも QAR も知らないし、あなたのためにトレードオフを決めることもできない。
- どんなに成功しているように見えても、他の組織からアーキテクチャをコピーしてはならない。彼らもまた、あなたのコンテキストや QAR を知らない。
- アーキテクチャを評価する唯一の方法は、構築してテストすることだ。設計を完璧にするためにこれを遅らせることは、失敗への道だ。

## 凝集度と結合度

保守性と生産性の高いコードを書くための尺度。
凝集度とは、関数の処理の役割の少なさを表す尺度。凝集度は高いほど良い
結合度とは、関数の独立性を表す尺度。結合度は、低いほど良い

## 開発手法

### Agile Development

### Lean Software Development

### DevOps

### Test-Driven Development

### Waterfall Model

### Spiral Model

## ソフトウェアのシステムコンポーネント設計におけるパターン

### DDD

### MVC (Model-View-Controller)

### MVVM (Model-View-ViewModel)

### Repository Pattern

### Dependency Injection (DI)

### Command Query Responsibility Segregation (CQRS)

### Event Sourcing

## [「Goの父」ロブ・パイクの「プログラミング5カ条」](https://gigazine.net/news/20200817-rob-pike-5-rules-programming/)

1. **ルール1**: プログラムのどこで処理時間がかかるかはわからない。ボトルネックは意外な場所で発生するので、ボトルネックがどこにあるかを証明するまでは、臆測で速度の改善に取り組まないこと。

2. **ルール2**: 処理速度を測定すること。測定して、コードのある部分が他の部分を圧倒しない限り、速度の調整をしてはいけない。

3. **ルール3**: 派手なアルゴリズムは、入力値のnが小さいと処理が遅い。そして通常、nは小さい。派手なアルゴリズムは大きな定数を持っている。nが頻繁に大きくなることがないなら、派手なアルゴリズムは使わないようにすること。(nが大きくなっても、まずルール2を適用すること)

4. **ルール4**: 派手なアルゴリズムは単純なアルゴリズムに比べてバグが多く、実装も大変なので、シンプルなアルゴリズムとシンプルなデータ構造を使うようにすること。

5. **ルール5**: データが支配する。正しいデータ構造を選択し、うまく整理していれば、アルゴリズムはほとんどの場合、自明のものになる。プログラミングの中心はアルゴリズムではなくデータ構造。

## References

- [保守性の高いソフトウェア開発のTips集](https://zenn.dev/riku/books/36d9873ee1c0e6)
- [良いコードとは何か - エンジニア新卒研修 スライド公開](https://note.com/cyberz_cto/n/n26f535d6c575)
- [技術選定/アーキテクチャ設計で後悔しないためのガイドライン](https://qiita.com/hirokidaichi/items/a746062917595619720b)
- [複雑さを相手に抽象化を盾にしましょう](https://tech.enigmo.co.jp/entry/2020/12/11/100000)
